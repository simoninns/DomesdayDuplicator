   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"cyfxtx.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.global	glMemPoolInit
  17              		.bss
  18              		.align	2
  21              	glMemPoolInit:
  22 0000 00000000 		.space	4
  23              		.comm	glMemBytePool,52,4
  24              		.global	glBufferManager
  25              		.align	2
  28              	glBufferManager:
  29 0004 00000000 		.space	76
  29      00000000 
  29      00000000 
  29      00000000 
  29      00000000 
  30              		.text
  31              		.align	2
  32              		.global	CyU3PUndefinedHandler
  34              	CyU3PUndefinedHandler:
  35              	.LFB0:
  36              		.file 1 "../cyfxtx.c"
   1:../cyfxtx.c   **** /*
   2:../cyfxtx.c   ****  ## Cypress USB 3.0 Platform source file (cyfxtx.c)
   3:../cyfxtx.c   ****  ## ===========================
   4:../cyfxtx.c   ****  ##
   5:../cyfxtx.c   ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2011,
   6:../cyfxtx.c   ****  ##  All Rights Reserved
   7:../cyfxtx.c   ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../cyfxtx.c   ****  ##
   9:../cyfxtx.c   ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../cyfxtx.c   ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../cyfxtx.c   ****  ##
  12:../cyfxtx.c   ****  ##  Use of this file is governed
  13:../cyfxtx.c   ****  ##  by the license agreement included in the file
  14:../cyfxtx.c   ****  ##
  15:../cyfxtx.c   ****  ##     <install>/license/license.txt
  16:../cyfxtx.c   ****  ##
  17:../cyfxtx.c   ****  ##  where <install> is the Cypress software
  18:../cyfxtx.c   ****  ##  installation root directory path.
  19:../cyfxtx.c   ****  ##
  20:../cyfxtx.c   ****  ## ===========================
  21:../cyfxtx.c   **** */
  22:../cyfxtx.c   **** 
  23:../cyfxtx.c   **** /* This file defines the porting required for the ThreadX RTOS.
  24:../cyfxtx.c   ****  * This file shall be provided in source form and must be compiled
  25:../cyfxtx.c   ****  * with the application source code
  26:../cyfxtx.c   ****  */
  27:../cyfxtx.c   **** 
  28:../cyfxtx.c   **** #include <cyu3os.h>
  29:../cyfxtx.c   **** #include <cyu3error.h>
  30:../cyfxtx.c   **** 
  31:../cyfxtx.c   **** /*
  32:../cyfxtx.c   ****    The MEM heap is a Memory byte pool which is used to allocate OS objects
  33:../cyfxtx.c   ****    such as thread stacks and memory for message queues. The Cypress FX3
  34:../cyfxtx.c   ****    libraries require a Mem heap size of at least 32 KB.
  35:../cyfxtx.c   ****  */
  36:../cyfxtx.c   **** #define CY_U3P_MEM_HEAP_BASE         ((uint8_t *)0x40038000)
  37:../cyfxtx.c   **** #define CY_U3P_MEM_HEAP_SIZE         (0x8000)
  38:../cyfxtx.c   **** 
  39:../cyfxtx.c   **** /* The last 32 KB of RAM is reserved for 2-stage boot operation. This value can be changed to
  40:../cyfxtx.c   ****    0x40080000 if 2-stage boot is not used by the application. */
  41:../cyfxtx.c   **** #define CY_U3P_SYS_MEM_TOP           (0x40078000)
  42:../cyfxtx.c   **** 
  43:../cyfxtx.c   **** /*
  44:../cyfxtx.c   ****    The buffer heap is used to obtain data buffers for DMA transfers in or out of
  45:../cyfxtx.c   ****    the FX3 device. The reference implementation of the buffer allocator makes use
  46:../cyfxtx.c   ****    of a reserved area in the SYSTEM RAM and ensures that all allocated DMA buffers
  47:../cyfxtx.c   ****    are aligned to cache lines.
  48:../cyfxtx.c   ****  */
  49:../cyfxtx.c   **** #define CY_U3P_BUFFER_HEAP_BASE      (((uint32_t)(CY_U3P_MEM_HEAP_BASE) + (CY_U3P_MEM_HEAP_SIZE)))
  50:../cyfxtx.c   **** #define CY_U3P_BUFFER_HEAP_SIZE      ((CY_U3P_SYS_MEM_TOP) - (CY_U3P_BUFFER_HEAP_BASE))
  51:../cyfxtx.c   **** 
  52:../cyfxtx.c   **** #define CY_U3P_BUFFER_ALLOC_TIMEOUT  (10)
  53:../cyfxtx.c   **** #define CY_U3P_MEM_ALLOC_TIMEOUT     (10)
  54:../cyfxtx.c   **** 
  55:../cyfxtx.c   **** #define CY_U3P_MAX(a,b)                 (((a) > (b)) ? (a) : (b))
  56:../cyfxtx.c   **** #define CY_U3P_MIN(a,b)                 (((a) < (b)) ? (a) : (b))
  57:../cyfxtx.c   **** 
  58:../cyfxtx.c   **** CyBool_t         glMemPoolInit = CyFalse;
  59:../cyfxtx.c   **** CyU3PBytePool    glMemBytePool;
  60:../cyfxtx.c   **** CyU3PDmaBufMgr_t glBufferManager = {{0}, 0, 0, 0, 0, 0};
  61:../cyfxtx.c   **** 
  62:../cyfxtx.c   **** /* These functions are exception handlers. These are default
  63:../cyfxtx.c   ****  * implementations and the application firmware can have a
  64:../cyfxtx.c   ****  * re-implementation. All these exceptions are not currently
  65:../cyfxtx.c   ****  * handled and are mapped to while (1) */
  66:../cyfxtx.c   **** 
  67:../cyfxtx.c   **** /* This function is the undefined instruction handler. This
  68:../cyfxtx.c   ****  * occurs when the CPU encounters an undefined instruction. */
  69:../cyfxtx.c   **** void
  70:../cyfxtx.c   **** CyU3PUndefinedHandler (
  71:../cyfxtx.c   ****         void)
  72:../cyfxtx.c   **** {
  37              		.loc 1 72 0
  38              		.cfi_startproc
  39              		@ args = 0, pretend = 0, frame = 0
  40              		@ frame_needed = 1, uses_anonymous_args = 0
  41              		@ link register save eliminated.
  42 0000 04B02DE5 		str	fp, [sp, #-4]!
  43              	.LCFI0:
  44              		.cfi_def_cfa_offset 4
  45              		.cfi_offset 11, -4
  46 0004 00B08DE2 		add	fp, sp, #0
  47              	.LCFI1:
  48              		.cfi_def_cfa_register 11
  49              	.L2:
  73:../cyfxtx.c   ****     for (;;);
  50              		.loc 1 73 0 discriminator 1
  51 0008 FEFFFFEA 		b	.L2
  52              		.cfi_endproc
  53              	.LFE0:
  55              		.align	2
  56              		.global	CyU3PPrefetchHandler
  58              	CyU3PPrefetchHandler:
  59              	.LFB1:
  74:../cyfxtx.c   **** }
  75:../cyfxtx.c   **** 
  76:../cyfxtx.c   **** /* This function is the intruction prefetch error handler. This
  77:../cyfxtx.c   ****  * occurs when the CPU encounters an instruction prefetch error.
  78:../cyfxtx.c   ****  * Since there are no virtual memory use case, this is an unknown
  79:../cyfxtx.c   ****  * memory access error. This is a fatal error. */
  80:../cyfxtx.c   **** void
  81:../cyfxtx.c   **** CyU3PPrefetchHandler (
  82:../cyfxtx.c   ****         void)
  83:../cyfxtx.c   **** {
  60              		.loc 1 83 0
  61              		.cfi_startproc
  62              		@ args = 0, pretend = 0, frame = 0
  63              		@ frame_needed = 1, uses_anonymous_args = 0
  64              		@ link register save eliminated.
  65 000c 04B02DE5 		str	fp, [sp, #-4]!
  66              	.LCFI2:
  67              		.cfi_def_cfa_offset 4
  68              		.cfi_offset 11, -4
  69 0010 00B08DE2 		add	fp, sp, #0
  70              	.LCFI3:
  71              		.cfi_def_cfa_register 11
  72              	.L4:
  84:../cyfxtx.c   ****     for (;;);
  73              		.loc 1 84 0 discriminator 1
  74 0014 FEFFFFEA 		b	.L4
  75              		.cfi_endproc
  76              	.LFE1:
  78              		.align	2
  79              		.global	CyU3PAbortHandler
  81              	CyU3PAbortHandler:
  82              	.LFB2:
  85:../cyfxtx.c   **** }
  86:../cyfxtx.c   **** 
  87:../cyfxtx.c   **** /* This function is the data abort error handler. This occurs when
  88:../cyfxtx.c   ****  * the CPU encounters an data prefetch error. Since there are no
  89:../cyfxtx.c   ****  * virtual memory use case, this is an unknown memory access error.
  90:../cyfxtx.c   ****  * This is a fatal error. */
  91:../cyfxtx.c   **** void
  92:../cyfxtx.c   **** CyU3PAbortHandler (
  93:../cyfxtx.c   ****         void)
  94:../cyfxtx.c   **** {
  83              		.loc 1 94 0
  84              		.cfi_startproc
  85              		@ args = 0, pretend = 0, frame = 0
  86              		@ frame_needed = 1, uses_anonymous_args = 0
  87              		@ link register save eliminated.
  88 0018 04B02DE5 		str	fp, [sp, #-4]!
  89              	.LCFI4:
  90              		.cfi_def_cfa_offset 4
  91              		.cfi_offset 11, -4
  92 001c 00B08DE2 		add	fp, sp, #0
  93              	.LCFI5:
  94              		.cfi_def_cfa_register 11
  95              	.L6:
  95:../cyfxtx.c   ****     for (;;);
  96              		.loc 1 95 0 discriminator 1
  97 0020 FEFFFFEA 		b	.L6
  98              		.cfi_endproc
  99              	.LFE2:
 101              		.align	2
 102              		.global	tx_application_define
 104              	tx_application_define:
 105              	.LFB3:
  96:../cyfxtx.c   **** }
  97:../cyfxtx.c   **** 
  98:../cyfxtx.c   **** /* This function is expected to be invoked by the RTOS kernel after
  99:../cyfxtx.c   ****  * initialization. No explicit call to this function must be made.
 100:../cyfxtx.c   ****  */
 101:../cyfxtx.c   **** void
 102:../cyfxtx.c   **** tx_application_define (
 103:../cyfxtx.c   ****         void *unusedMem)
 104:../cyfxtx.c   **** {
 106              		.loc 1 104 0
 107              		.cfi_startproc
 108              		@ args = 0, pretend = 0, frame = 8
 109              		@ frame_needed = 1, uses_anonymous_args = 0
 110 0024 00482DE9 		stmfd	sp!, {fp, lr}
 111              	.LCFI6:
 112              		.cfi_def_cfa_offset 8
 113              		.cfi_offset 11, -8
 114              		.cfi_offset 14, -4
 115 0028 04B08DE2 		add	fp, sp, #4
 116              	.LCFI7:
 117              		.cfi_def_cfa 11, 4
 118 002c 08D04DE2 		sub	sp, sp, #8
 119 0030 08000BE5 		str	r0, [fp, #-8]
 105:../cyfxtx.c   ****     (void) unusedMem;
 106:../cyfxtx.c   ****     CyU3PApplicationDefine ();
 120              		.loc 1 106 0
 121 0034 FEFFFFEB 		bl	CyU3PApplicationDefine
 107:../cyfxtx.c   **** }
 122              		.loc 1 107 0
 123 0038 04D04BE2 		sub	sp, fp, #4
 124              		@ sp needed
 125 003c 0088BDE8 		ldmfd	sp!, {fp, pc}
 126              		.cfi_endproc
 127              	.LFE3:
 129              		.align	2
 130              		.global	CyU3PMemInit
 132              	CyU3PMemInit:
 133              	.LFB4:
 108:../cyfxtx.c   **** 
 109:../cyfxtx.c   **** /* This function initializes the custom heap for OS specific dynamic memory allocation.
 110:../cyfxtx.c   ****  * The function should not be explicitly invoked. This function is called from the 
 111:../cyfxtx.c   ****  * API library. Modify this function depending upon the heap requirement of 
 112:../cyfxtx.c   ****  * application code. The minimum required value is specified by the predefined macro.
 113:../cyfxtx.c   ****  * Any value less than specified can cause the drivers to stop functioning.
 114:../cyfxtx.c   ****  * The function creates a global byte pool.
 115:../cyfxtx.c   ****  */
 116:../cyfxtx.c   **** void
 117:../cyfxtx.c   **** CyU3PMemInit (
 118:../cyfxtx.c   ****         void)
 119:../cyfxtx.c   **** {
 134              		.loc 1 119 0
 135              		.cfi_startproc
 136              		@ args = 0, pretend = 0, frame = 0
 137              		@ frame_needed = 1, uses_anonymous_args = 0
 138 0040 00482DE9 		stmfd	sp!, {fp, lr}
 139              	.LCFI8:
 140              		.cfi_def_cfa_offset 8
 141              		.cfi_offset 11, -8
 142              		.cfi_offset 14, -4
 143 0044 04B08DE2 		add	fp, sp, #4
 144              	.LCFI9:
 145              		.cfi_def_cfa 11, 4
 146 0048 08D04DE2 		sub	sp, sp, #8
 120:../cyfxtx.c   ****     if (!glMemPoolInit)
 147              		.loc 1 120 0
 148 004c 38309FE5 		ldr	r3, .L10
 149 0050 003093E5 		ldr	r3, [r3]
 150 0054 000053E3 		cmp	r3, #0
 151 0058 0900001A 		bne	.L8
 121:../cyfxtx.c   ****     {
 122:../cyfxtx.c   **** 	glMemPoolInit = CyTrue;
 152              		.loc 1 122 0
 153 005c 28309FE5 		ldr	r3, .L10
 154 0060 0120A0E3 		mov	r2, #1
 155 0064 002083E5 		str	r2, [r3]
 123:../cyfxtx.c   **** 	CyU3PBytePoolCreate (&glMemBytePool, CY_U3P_MEM_HEAP_BASE, CY_U3P_MEM_HEAP_SIZE);
 156              		.loc 1 123 0
 157 0068 3430A0E3 		mov	r3, #52
 158 006c 00308DE5 		str	r3, [sp]
 159 0070 18009FE5 		ldr	r0, .L10+4
 160 0074 0010A0E3 		mov	r1, #0
 161 0078 14209FE5 		ldr	r2, .L10+8
 162 007c 0239A0E3 		mov	r3, #32768
 163 0080 FEFFFFEB 		bl	_txe_byte_pool_create
 164              	.L8:
 124:../cyfxtx.c   ****     }
 125:../cyfxtx.c   **** }
 165              		.loc 1 125 0
 166 0084 04D04BE2 		sub	sp, fp, #4
 167              		@ sp needed
 168 0088 0088BDE8 		ldmfd	sp!, {fp, pc}
 169              	.L11:
 170              		.align	2
 171              	.L10:
 172 008c 00000000 		.word	glMemPoolInit
 173 0090 00000000 		.word	glMemBytePool
 174 0094 00800340 		.word	1073971200
 175              		.cfi_endproc
 176              	.LFE4:
 178              		.align	2
 179              		.global	CyU3PMemAlloc
 181              	CyU3PMemAlloc:
 182              	.LFB5:
 126:../cyfxtx.c   **** 
 127:../cyfxtx.c   **** void *
 128:../cyfxtx.c   **** CyU3PMemAlloc (
 129:../cyfxtx.c   ****         uint32_t size)
 130:../cyfxtx.c   **** {
 183              		.loc 1 130 0
 184              		.cfi_startproc
 185              		@ args = 0, pretend = 0, frame = 16
 186              		@ frame_needed = 1, uses_anonymous_args = 0
 187 0098 00482DE9 		stmfd	sp!, {fp, lr}
 188              	.LCFI10:
 189              		.cfi_def_cfa_offset 8
 190              		.cfi_offset 11, -8
 191              		.cfi_offset 14, -4
 192 009c 04B08DE2 		add	fp, sp, #4
 193              	.LCFI11:
 194              		.cfi_def_cfa 11, 4
 195 00a0 10D04DE2 		sub	sp, sp, #16
 196 00a4 10000BE5 		str	r0, [fp, #-16]
 131:../cyfxtx.c   ****     void     *ret_p;
 132:../cyfxtx.c   ****     uint32_t status;
 133:../cyfxtx.c   **** 
 134:../cyfxtx.c   ****     /* Cannot wait in interrupt context */
 135:../cyfxtx.c   ****     if (CyU3PThreadIdentify ())
 197              		.loc 1 135 0
 198 00a8 FEFFFFEB 		bl	_tx_thread_identify
 199 00ac 0030A0E1 		mov	r3, r0
 200 00b0 000053E3 		cmp	r3, #0
 201 00b4 0700000A 		beq	.L13
 136:../cyfxtx.c   ****     {
 137:../cyfxtx.c   ****         status = CyU3PByteAlloc (&glMemBytePool, (void **)&ret_p, size, CY_U3P_MEM_ALLOC_TIMEOUT);
 202              		.loc 1 137 0
 203 00b8 0C304BE2 		sub	r3, fp, #12
 204 00bc 54009FE5 		ldr	r0, .L18
 205 00c0 0310A0E1 		mov	r1, r3
 206 00c4 10201BE5 		ldr	r2, [fp, #-16]
 207 00c8 0A30A0E3 		mov	r3, #10
 208 00cc FEFFFFEB 		bl	_txe_byte_allocate
 209 00d0 08000BE5 		str	r0, [fp, #-8]
 210 00d4 060000EA 		b	.L14
 211              	.L13:
 138:../cyfxtx.c   ****     }
 139:../cyfxtx.c   ****     else
 140:../cyfxtx.c   ****     {
 141:../cyfxtx.c   ****         status = CyU3PByteAlloc (&glMemBytePool, (void **)&ret_p, size, CYU3P_NO_WAIT);
 212              		.loc 1 141 0
 213 00d8 0C304BE2 		sub	r3, fp, #12
 214 00dc 34009FE5 		ldr	r0, .L18
 215 00e0 0310A0E1 		mov	r1, r3
 216 00e4 10201BE5 		ldr	r2, [fp, #-16]
 217 00e8 0030A0E3 		mov	r3, #0
 218 00ec FEFFFFEB 		bl	_txe_byte_allocate
 219 00f0 08000BE5 		str	r0, [fp, #-8]
 220              	.L14:
 142:../cyfxtx.c   ****     }
 143:../cyfxtx.c   **** 
 144:../cyfxtx.c   ****     if(status == CY_U3P_SUCCESS)
 221              		.loc 1 144 0
 222 00f4 08301BE5 		ldr	r3, [fp, #-8]
 223 00f8 000053E3 		cmp	r3, #0
 224 00fc 0100001A 		bne	.L15
 145:../cyfxtx.c   ****     {
 146:../cyfxtx.c   ****         return ret_p;
 225              		.loc 1 146 0
 226 0100 0C301BE5 		ldr	r3, [fp, #-12]
 227 0104 000000EA 		b	.L17
 228              	.L15:
 147:../cyfxtx.c   ****     }
 148:../cyfxtx.c   **** 
 149:../cyfxtx.c   ****     return (NULL);
 229              		.loc 1 149 0
 230 0108 0030A0E3 		mov	r3, #0
 231              	.L17:
 150:../cyfxtx.c   **** }
 232              		.loc 1 150 0
 233 010c 0300A0E1 		mov	r0, r3
 234 0110 04D04BE2 		sub	sp, fp, #4
 235              		@ sp needed
 236 0114 0088BDE8 		ldmfd	sp!, {fp, pc}
 237              	.L19:
 238              		.align	2
 239              	.L18:
 240 0118 00000000 		.word	glMemBytePool
 241              		.cfi_endproc
 242              	.LFE5:
 244              		.align	2
 245              		.global	CyU3PMemFree
 247              	CyU3PMemFree:
 248              	.LFB6:
 151:../cyfxtx.c   **** 
 152:../cyfxtx.c   **** void
 153:../cyfxtx.c   **** CyU3PMemFree (
 154:../cyfxtx.c   ****         void *mem_p)
 155:../cyfxtx.c   **** {
 249              		.loc 1 155 0
 250              		.cfi_startproc
 251              		@ args = 0, pretend = 0, frame = 8
 252              		@ frame_needed = 1, uses_anonymous_args = 0
 253 011c 00482DE9 		stmfd	sp!, {fp, lr}
 254              	.LCFI12:
 255              		.cfi_def_cfa_offset 8
 256              		.cfi_offset 11, -8
 257              		.cfi_offset 14, -4
 258 0120 04B08DE2 		add	fp, sp, #4
 259              	.LCFI13:
 260              		.cfi_def_cfa 11, 4
 261 0124 08D04DE2 		sub	sp, sp, #8
 262 0128 08000BE5 		str	r0, [fp, #-8]
 156:../cyfxtx.c   ****     CyU3PByteFree (mem_p);
 263              		.loc 1 156 0
 264 012c 08001BE5 		ldr	r0, [fp, #-8]
 265 0130 FEFFFFEB 		bl	_txe_byte_release
 157:../cyfxtx.c   **** }
 266              		.loc 1 157 0
 267 0134 04D04BE2 		sub	sp, fp, #4
 268              		@ sp needed
 269 0138 0088BDE8 		ldmfd	sp!, {fp, pc}
 270              		.cfi_endproc
 271              	.LFE6:
 273              		.align	2
 274              		.global	CyU3PMemSet
 276              	CyU3PMemSet:
 277              	.LFB7:
 158:../cyfxtx.c   **** 
 159:../cyfxtx.c   **** void
 160:../cyfxtx.c   **** CyU3PMemSet (
 161:../cyfxtx.c   ****         uint8_t *ptr,
 162:../cyfxtx.c   ****         uint8_t data,
 163:../cyfxtx.c   ****         uint32_t count)
 164:../cyfxtx.c   **** {
 278              		.loc 1 164 0
 279              		.cfi_startproc
 280              		@ args = 0, pretend = 0, frame = 16
 281              		@ frame_needed = 1, uses_anonymous_args = 0
 282              		@ link register save eliminated.
 283 013c 04B02DE5 		str	fp, [sp, #-4]!
 284              	.LCFI14:
 285              		.cfi_def_cfa_offset 4
 286              		.cfi_offset 11, -4
 287 0140 00B08DE2 		add	fp, sp, #0
 288              	.LCFI15:
 289              		.cfi_def_cfa_register 11
 290 0144 14D04DE2 		sub	sp, sp, #20
 291 0148 08000BE5 		str	r0, [fp, #-8]
 292 014c 0130A0E1 		mov	r3, r1
 293 0150 10200BE5 		str	r2, [fp, #-16]
 294 0154 09304BE5 		strb	r3, [fp, #-9]
 165:../cyfxtx.c   ****     /* Loop unrolling for faster operation */
 166:../cyfxtx.c   ****     while (count >> 3)
 295              		.loc 1 166 0
 296 0158 240000EA 		b	.L22
 297              	.L23:
 167:../cyfxtx.c   ****     {
 168:../cyfxtx.c   ****         ptr[0] = data;
 298              		.loc 1 168 0
 299 015c 08301BE5 		ldr	r3, [fp, #-8]
 300 0160 09205BE5 		ldrb	r2, [fp, #-9]
 301 0164 0020C3E5 		strb	r2, [r3]
 169:../cyfxtx.c   ****         ptr[1] = data;
 302              		.loc 1 169 0
 303 0168 08301BE5 		ldr	r3, [fp, #-8]
 304 016c 013083E2 		add	r3, r3, #1
 305 0170 09205BE5 		ldrb	r2, [fp, #-9]
 306 0174 0020C3E5 		strb	r2, [r3]
 170:../cyfxtx.c   ****         ptr[2] = data;
 307              		.loc 1 170 0
 308 0178 08301BE5 		ldr	r3, [fp, #-8]
 309 017c 023083E2 		add	r3, r3, #2
 310 0180 09205BE5 		ldrb	r2, [fp, #-9]
 311 0184 0020C3E5 		strb	r2, [r3]
 171:../cyfxtx.c   ****         ptr[3] = data;
 312              		.loc 1 171 0
 313 0188 08301BE5 		ldr	r3, [fp, #-8]
 314 018c 033083E2 		add	r3, r3, #3
 315 0190 09205BE5 		ldrb	r2, [fp, #-9]
 316 0194 0020C3E5 		strb	r2, [r3]
 172:../cyfxtx.c   ****         ptr[4] = data;
 317              		.loc 1 172 0
 318 0198 08301BE5 		ldr	r3, [fp, #-8]
 319 019c 043083E2 		add	r3, r3, #4
 320 01a0 09205BE5 		ldrb	r2, [fp, #-9]
 321 01a4 0020C3E5 		strb	r2, [r3]
 173:../cyfxtx.c   ****         ptr[5] = data;
 322              		.loc 1 173 0
 323 01a8 08301BE5 		ldr	r3, [fp, #-8]
 324 01ac 053083E2 		add	r3, r3, #5
 325 01b0 09205BE5 		ldrb	r2, [fp, #-9]
 326 01b4 0020C3E5 		strb	r2, [r3]
 174:../cyfxtx.c   ****         ptr[6] = data;
 327              		.loc 1 174 0
 328 01b8 08301BE5 		ldr	r3, [fp, #-8]
 329 01bc 063083E2 		add	r3, r3, #6
 330 01c0 09205BE5 		ldrb	r2, [fp, #-9]
 331 01c4 0020C3E5 		strb	r2, [r3]
 175:../cyfxtx.c   ****         ptr[7] = data;
 332              		.loc 1 175 0
 333 01c8 08301BE5 		ldr	r3, [fp, #-8]
 334 01cc 073083E2 		add	r3, r3, #7
 335 01d0 09205BE5 		ldrb	r2, [fp, #-9]
 336 01d4 0020C3E5 		strb	r2, [r3]
 176:../cyfxtx.c   **** 
 177:../cyfxtx.c   ****         count -= 8;
 337              		.loc 1 177 0
 338 01d8 10301BE5 		ldr	r3, [fp, #-16]
 339 01dc 083043E2 		sub	r3, r3, #8
 340 01e0 10300BE5 		str	r3, [fp, #-16]
 178:../cyfxtx.c   ****         ptr += 8;
 341              		.loc 1 178 0
 342 01e4 08301BE5 		ldr	r3, [fp, #-8]
 343 01e8 083083E2 		add	r3, r3, #8
 344 01ec 08300BE5 		str	r3, [fp, #-8]
 345              	.L22:
 166:../cyfxtx.c   ****     {
 346              		.loc 1 166 0 discriminator 1
 347 01f0 10301BE5 		ldr	r3, [fp, #-16]
 348 01f4 A331A0E1 		mov	r3, r3, lsr #3
 349 01f8 000053E3 		cmp	r3, #0
 350 01fc D6FFFF1A 		bne	.L23
 179:../cyfxtx.c   ****     }
 180:../cyfxtx.c   **** 
 181:../cyfxtx.c   ****     while (count--)
 351              		.loc 1 181 0
 352 0200 050000EA 		b	.L24
 353              	.L25:
 182:../cyfxtx.c   ****     {
 183:../cyfxtx.c   ****         *ptr = data;
 354              		.loc 1 183 0
 355 0204 08301BE5 		ldr	r3, [fp, #-8]
 356 0208 09205BE5 		ldrb	r2, [fp, #-9]
 357 020c 0020C3E5 		strb	r2, [r3]
 184:../cyfxtx.c   ****         ptr++;
 358              		.loc 1 184 0
 359 0210 08301BE5 		ldr	r3, [fp, #-8]
 360 0214 013083E2 		add	r3, r3, #1
 361 0218 08300BE5 		str	r3, [fp, #-8]
 362              	.L24:
 181:../cyfxtx.c   ****     {
 363              		.loc 1 181 0 discriminator 1
 364 021c 10301BE5 		ldr	r3, [fp, #-16]
 365 0220 012043E2 		sub	r2, r3, #1
 366 0224 10200BE5 		str	r2, [fp, #-16]
 367 0228 000053E3 		cmp	r3, #0
 368 022c F4FFFF1A 		bne	.L25
 185:../cyfxtx.c   ****     }
 186:../cyfxtx.c   **** }
 369              		.loc 1 186 0
 370 0230 00D04BE2 		sub	sp, fp, #0
 371              		@ sp needed
 372 0234 04B09DE4 		ldr	fp, [sp], #4
 373 0238 1EFF2FE1 		bx	lr
 374              		.cfi_endproc
 375              	.LFE7:
 377              		.align	2
 378              		.global	CyU3PMemCopy
 380              	CyU3PMemCopy:
 381              	.LFB8:
 187:../cyfxtx.c   **** 
 188:../cyfxtx.c   **** void
 189:../cyfxtx.c   **** CyU3PMemCopy (
 190:../cyfxtx.c   ****         uint8_t *dest, 
 191:../cyfxtx.c   ****         uint8_t *src,
 192:../cyfxtx.c   ****         uint32_t count)
 193:../cyfxtx.c   **** {
 382              		.loc 1 193 0
 383              		.cfi_startproc
 384              		@ args = 0, pretend = 0, frame = 16
 385              		@ frame_needed = 1, uses_anonymous_args = 0
 386              		@ link register save eliminated.
 387 023c 04B02DE5 		str	fp, [sp, #-4]!
 388              	.LCFI16:
 389              		.cfi_def_cfa_offset 4
 390              		.cfi_offset 11, -4
 391 0240 00B08DE2 		add	fp, sp, #0
 392              	.LCFI17:
 393              		.cfi_def_cfa_register 11
 394 0244 14D04DE2 		sub	sp, sp, #20
 395 0248 08000BE5 		str	r0, [fp, #-8]
 396 024c 0C100BE5 		str	r1, [fp, #-12]
 397 0250 10200BE5 		str	r2, [fp, #-16]
 194:../cyfxtx.c   ****     /* Loop unrolling for faster operation */
 195:../cyfxtx.c   ****     while (count >> 3)
 398              		.loc 1 195 0
 399 0254 2F0000EA 		b	.L27
 400              	.L28:
 196:../cyfxtx.c   ****     {
 197:../cyfxtx.c   ****         dest[0] = src[0];
 401              		.loc 1 197 0
 402 0258 0C301BE5 		ldr	r3, [fp, #-12]
 403 025c 0020D3E5 		ldrb	r2, [r3]	@ zero_extendqisi2
 404 0260 08301BE5 		ldr	r3, [fp, #-8]
 405 0264 0020C3E5 		strb	r2, [r3]
 198:../cyfxtx.c   ****         dest[1] = src[1];
 406              		.loc 1 198 0
 407 0268 08301BE5 		ldr	r3, [fp, #-8]
 408 026c 013083E2 		add	r3, r3, #1
 409 0270 0C201BE5 		ldr	r2, [fp, #-12]
 410 0274 0120D2E5 		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 411 0278 0020C3E5 		strb	r2, [r3]
 199:../cyfxtx.c   ****         dest[2] = src[2];
 412              		.loc 1 199 0
 413 027c 08301BE5 		ldr	r3, [fp, #-8]
 414 0280 023083E2 		add	r3, r3, #2
 415 0284 0C201BE5 		ldr	r2, [fp, #-12]
 416 0288 0220D2E5 		ldrb	r2, [r2, #2]	@ zero_extendqisi2
 417 028c 0020C3E5 		strb	r2, [r3]
 200:../cyfxtx.c   ****         dest[3] = src[3];
 418              		.loc 1 200 0
 419 0290 08301BE5 		ldr	r3, [fp, #-8]
 420 0294 033083E2 		add	r3, r3, #3
 421 0298 0C201BE5 		ldr	r2, [fp, #-12]
 422 029c 0320D2E5 		ldrb	r2, [r2, #3]	@ zero_extendqisi2
 423 02a0 0020C3E5 		strb	r2, [r3]
 201:../cyfxtx.c   ****         dest[4] = src[4];
 424              		.loc 1 201 0
 425 02a4 08301BE5 		ldr	r3, [fp, #-8]
 426 02a8 043083E2 		add	r3, r3, #4
 427 02ac 0C201BE5 		ldr	r2, [fp, #-12]
 428 02b0 0420D2E5 		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 429 02b4 0020C3E5 		strb	r2, [r3]
 202:../cyfxtx.c   ****         dest[5] = src[5];
 430              		.loc 1 202 0
 431 02b8 08301BE5 		ldr	r3, [fp, #-8]
 432 02bc 053083E2 		add	r3, r3, #5
 433 02c0 0C201BE5 		ldr	r2, [fp, #-12]
 434 02c4 0520D2E5 		ldrb	r2, [r2, #5]	@ zero_extendqisi2
 435 02c8 0020C3E5 		strb	r2, [r3]
 203:../cyfxtx.c   ****         dest[6] = src[6];
 436              		.loc 1 203 0
 437 02cc 08301BE5 		ldr	r3, [fp, #-8]
 438 02d0 063083E2 		add	r3, r3, #6
 439 02d4 0C201BE5 		ldr	r2, [fp, #-12]
 440 02d8 0620D2E5 		ldrb	r2, [r2, #6]	@ zero_extendqisi2
 441 02dc 0020C3E5 		strb	r2, [r3]
 204:../cyfxtx.c   ****         dest[7] = src[7];
 442              		.loc 1 204 0
 443 02e0 08301BE5 		ldr	r3, [fp, #-8]
 444 02e4 073083E2 		add	r3, r3, #7
 445 02e8 0C201BE5 		ldr	r2, [fp, #-12]
 446 02ec 0720D2E5 		ldrb	r2, [r2, #7]	@ zero_extendqisi2
 447 02f0 0020C3E5 		strb	r2, [r3]
 205:../cyfxtx.c   **** 
 206:../cyfxtx.c   ****         count -= 8;
 448              		.loc 1 206 0
 449 02f4 10301BE5 		ldr	r3, [fp, #-16]
 450 02f8 083043E2 		sub	r3, r3, #8
 451 02fc 10300BE5 		str	r3, [fp, #-16]
 207:../cyfxtx.c   ****         dest += 8;
 452              		.loc 1 207 0
 453 0300 08301BE5 		ldr	r3, [fp, #-8]
 454 0304 083083E2 		add	r3, r3, #8
 455 0308 08300BE5 		str	r3, [fp, #-8]
 208:../cyfxtx.c   ****         src += 8;
 456              		.loc 1 208 0
 457 030c 0C301BE5 		ldr	r3, [fp, #-12]
 458 0310 083083E2 		add	r3, r3, #8
 459 0314 0C300BE5 		str	r3, [fp, #-12]
 460              	.L27:
 195:../cyfxtx.c   ****     {
 461              		.loc 1 195 0 discriminator 1
 462 0318 10301BE5 		ldr	r3, [fp, #-16]
 463 031c A331A0E1 		mov	r3, r3, lsr #3
 464 0320 000053E3 		cmp	r3, #0
 465 0324 CBFFFF1A 		bne	.L28
 209:../cyfxtx.c   ****     }
 210:../cyfxtx.c   **** 
 211:../cyfxtx.c   ****     while (count--)
 466              		.loc 1 211 0
 467 0328 090000EA 		b	.L29
 468              	.L30:
 212:../cyfxtx.c   ****     {
 213:../cyfxtx.c   ****         *dest = *src;
 469              		.loc 1 213 0
 470 032c 0C301BE5 		ldr	r3, [fp, #-12]
 471 0330 0020D3E5 		ldrb	r2, [r3]	@ zero_extendqisi2
 472 0334 08301BE5 		ldr	r3, [fp, #-8]
 473 0338 0020C3E5 		strb	r2, [r3]
 214:../cyfxtx.c   ****         dest++;
 474              		.loc 1 214 0
 475 033c 08301BE5 		ldr	r3, [fp, #-8]
 476 0340 013083E2 		add	r3, r3, #1
 477 0344 08300BE5 		str	r3, [fp, #-8]
 215:../cyfxtx.c   ****         src++;
 478              		.loc 1 215 0
 479 0348 0C301BE5 		ldr	r3, [fp, #-12]
 480 034c 013083E2 		add	r3, r3, #1
 481 0350 0C300BE5 		str	r3, [fp, #-12]
 482              	.L29:
 211:../cyfxtx.c   ****     {
 483              		.loc 1 211 0 discriminator 1
 484 0354 10301BE5 		ldr	r3, [fp, #-16]
 485 0358 012043E2 		sub	r2, r3, #1
 486 035c 10200BE5 		str	r2, [fp, #-16]
 487 0360 000053E3 		cmp	r3, #0
 488 0364 F0FFFF1A 		bne	.L30
 216:../cyfxtx.c   ****     }
 217:../cyfxtx.c   **** }
 489              		.loc 1 217 0
 490 0368 00D04BE2 		sub	sp, fp, #0
 491              		@ sp needed
 492 036c 04B09DE4 		ldr	fp, [sp], #4
 493 0370 1EFF2FE1 		bx	lr
 494              		.cfi_endproc
 495              	.LFE8:
 497              		.align	2
 498              		.global	CyU3PMemCmp
 500              	CyU3PMemCmp:
 501              	.LFB9:
 218:../cyfxtx.c   **** 
 219:../cyfxtx.c   **** int32_t 
 220:../cyfxtx.c   **** CyU3PMemCmp (
 221:../cyfxtx.c   ****         const void* s1,
 222:../cyfxtx.c   ****         const void* s2, 
 223:../cyfxtx.c   ****         uint32_t n)
 224:../cyfxtx.c   **** {
 502              		.loc 1 224 0
 503              		.cfi_startproc
 504              		@ args = 0, pretend = 0, frame = 24
 505              		@ frame_needed = 1, uses_anonymous_args = 0
 506              		@ link register save eliminated.
 507 0374 04B02DE5 		str	fp, [sp, #-4]!
 508              	.LCFI18:
 509              		.cfi_def_cfa_offset 4
 510              		.cfi_offset 11, -4
 511 0378 00B08DE2 		add	fp, sp, #0
 512              	.LCFI19:
 513              		.cfi_def_cfa_register 11
 514 037c 1CD04DE2 		sub	sp, sp, #28
 515 0380 10000BE5 		str	r0, [fp, #-16]
 516 0384 14100BE5 		str	r1, [fp, #-20]
 517 0388 18200BE5 		str	r2, [fp, #-24]
 225:../cyfxtx.c   ****     const uint8_t *ptr1 = s1, *ptr2 = s2;
 518              		.loc 1 225 0
 519 038c 10301BE5 		ldr	r3, [fp, #-16]
 520 0390 08300BE5 		str	r3, [fp, #-8]
 521 0394 14301BE5 		ldr	r3, [fp, #-20]
 522 0398 0C300BE5 		str	r3, [fp, #-12]
 226:../cyfxtx.c   **** 
 227:../cyfxtx.c   ****     while(n--)
 523              		.loc 1 227 0
 524 039c 120000EA 		b	.L32
 525              	.L35:
 228:../cyfxtx.c   ****     {
 229:../cyfxtx.c   ****         if(*ptr1 != *ptr2)
 526              		.loc 1 229 0
 527 03a0 08301BE5 		ldr	r3, [fp, #-8]
 528 03a4 0020D3E5 		ldrb	r2, [r3]	@ zero_extendqisi2
 529 03a8 0C301BE5 		ldr	r3, [fp, #-12]
 530 03ac 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 531 03b0 030052E1 		cmp	r2, r3
 532 03b4 0600000A 		beq	.L33
 230:../cyfxtx.c   ****         {
 231:../cyfxtx.c   ****             return *ptr1 - *ptr2;
 533              		.loc 1 231 0
 534 03b8 08301BE5 		ldr	r3, [fp, #-8]
 535 03bc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 536 03c0 0320A0E1 		mov	r2, r3
 537 03c4 0C301BE5 		ldr	r3, [fp, #-12]
 538 03c8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 539 03cc 023063E0 		rsb	r3, r3, r2
 540 03d0 0B0000EA 		b	.L34
 541              	.L33:
 232:../cyfxtx.c   ****         }
 233:../cyfxtx.c   ****         
 234:../cyfxtx.c   ****         ptr1++;
 542              		.loc 1 234 0
 543 03d4 08301BE5 		ldr	r3, [fp, #-8]
 544 03d8 013083E2 		add	r3, r3, #1
 545 03dc 08300BE5 		str	r3, [fp, #-8]
 235:../cyfxtx.c   ****         ptr2++;
 546              		.loc 1 235 0
 547 03e0 0C301BE5 		ldr	r3, [fp, #-12]
 548 03e4 013083E2 		add	r3, r3, #1
 549 03e8 0C300BE5 		str	r3, [fp, #-12]
 550              	.L32:
 227:../cyfxtx.c   ****     {
 551              		.loc 1 227 0 discriminator 1
 552 03ec 18301BE5 		ldr	r3, [fp, #-24]
 553 03f0 012043E2 		sub	r2, r3, #1
 554 03f4 18200BE5 		str	r2, [fp, #-24]
 555 03f8 000053E3 		cmp	r3, #0
 556 03fc E7FFFF1A 		bne	.L35
 236:../cyfxtx.c   ****     }  
 237:../cyfxtx.c   ****     return 0;
 557              		.loc 1 237 0
 558 0400 0030A0E3 		mov	r3, #0
 559              	.L34:
 238:../cyfxtx.c   **** }
 560              		.loc 1 238 0
 561 0404 0300A0E1 		mov	r0, r3
 562 0408 00D04BE2 		sub	sp, fp, #0
 563              		@ sp needed
 564 040c 04B09DE4 		ldr	fp, [sp], #4
 565 0410 1EFF2FE1 		bx	lr
 566              		.cfi_endproc
 567              	.LFE9:
 569              		.align	2
 570              		.global	CyU3PDmaBufferInit
 572              	CyU3PDmaBufferInit:
 573              	.LFB10:
 239:../cyfxtx.c   **** 
 240:../cyfxtx.c   **** /* This function shall be invoked by the API library 
 241:../cyfxtx.c   ****  * and should not be explicitly invoked.
 242:../cyfxtx.c   ****  * If other buffer sizes are required by the application code, this function must
 243:../cyfxtx.c   ****  * be modified to create other block pools.
 244:../cyfxtx.c   ****  */
 245:../cyfxtx.c   **** void
 246:../cyfxtx.c   **** CyU3PDmaBufferInit (
 247:../cyfxtx.c   ****         void)
 248:../cyfxtx.c   **** {
 574              		.loc 1 248 0
 575              		.cfi_startproc
 576              		@ args = 0, pretend = 0, frame = 8
 577              		@ frame_needed = 1, uses_anonymous_args = 0
 578 0414 00482DE9 		stmfd	sp!, {fp, lr}
 579              	.LCFI20:
 580              		.cfi_def_cfa_offset 8
 581              		.cfi_offset 11, -8
 582              		.cfi_offset 14, -4
 583 0418 04B08DE2 		add	fp, sp, #4
 584              	.LCFI21:
 585              		.cfi_def_cfa 11, 4
 586 041c 08D04DE2 		sub	sp, sp, #8
 249:../cyfxtx.c   ****     uint32_t status, size;
 250:../cyfxtx.c   ****     uint32_t tmp;
 251:../cyfxtx.c   **** 
 252:../cyfxtx.c   ****     /* If buffer manager has already been initialized, just return. */
 253:../cyfxtx.c   ****     if ((glBufferManager.startAddr != 0) && (glBufferManager.regionSize != 0))
 587              		.loc 1 253 0
 588 0420 DC309FE5 		ldr	r3, .L41
 589 0424 383093E5 		ldr	r3, [r3, #56]
 590 0428 000053E3 		cmp	r3, #0
 591 042c 0400000A 		beq	.L37
 592              		.loc 1 253 0 is_stmt 0 discriminator 1
 593 0430 CC309FE5 		ldr	r3, .L41
 594 0434 3C3093E5 		ldr	r3, [r3, #60]
 595 0438 000053E3 		cmp	r3, #0
 596 043c 0000000A 		beq	.L37
 254:../cyfxtx.c   ****     {
 255:../cyfxtx.c   ****         return;
 597              		.loc 1 255 0 is_stmt 1
 598 0440 2D0000EA 		b	.L36
 599              	.L37:
 256:../cyfxtx.c   ****     }
 257:../cyfxtx.c   **** 
 258:../cyfxtx.c   ****     /* Create a mutex variable for safe allocation. */
 259:../cyfxtx.c   ****     status = CyU3PMutexCreate (&glBufferManager.lock, CYU3P_NO_INHERIT);
 600              		.loc 1 259 0
 601 0444 B8009FE5 		ldr	r0, .L41
 602 0448 0010A0E3 		mov	r1, #0
 603 044c 0020A0E3 		mov	r2, #0
 604 0450 3830A0E3 		mov	r3, #56
 605 0454 FEFFFFEB 		bl	_txe_mutex_create
 606 0458 08000BE5 		str	r0, [fp, #-8]
 260:../cyfxtx.c   ****     if (status != CY_U3P_SUCCESS)
 607              		.loc 1 260 0
 608 045c 08301BE5 		ldr	r3, [fp, #-8]
 609 0460 000053E3 		cmp	r3, #0
 610 0464 0000000A 		beq	.L39
 261:../cyfxtx.c   ****     {
 262:../cyfxtx.c   ****         return;
 611              		.loc 1 262 0
 612 0468 230000EA 		b	.L36
 613              	.L39:
 263:../cyfxtx.c   ****     }
 264:../cyfxtx.c   **** 
 265:../cyfxtx.c   ****     /* No threads are running at this point in time. There is no need to
 266:../cyfxtx.c   ****        get the mutex. */
 267:../cyfxtx.c   **** 
 268:../cyfxtx.c   ****     /* Allocate the memory buffer to be used to track memory status.
 269:../cyfxtx.c   ****        We need one bit per 32 bytes of memory buffer space. Since a 32
 270:../cyfxtx.c   ****        bit array is being used, round up to the necessary number of
 271:../cyfxtx.c   ****        32 bit words. */
 272:../cyfxtx.c   ****     size = ((CY_U3P_BUFFER_HEAP_SIZE / 32) + 31) / 32;
 614              		.loc 1 272 0
 615 046c E030A0E3 		mov	r3, #224
 616 0470 0C300BE5 		str	r3, [fp, #-12]
 273:../cyfxtx.c   ****     glBufferManager.usedStatus = (uint32_t *)CyU3PMemAlloc (size * 4);
 617              		.loc 1 273 0
 618 0474 0C301BE5 		ldr	r3, [fp, #-12]
 619 0478 0331A0E1 		mov	r3, r3, asl #2
 620 047c 0300A0E1 		mov	r0, r3
 621 0480 FEFFFFEB 		bl	CyU3PMemAlloc
 622 0484 0020A0E1 		mov	r2, r0
 623 0488 74309FE5 		ldr	r3, .L41
 624 048c 402083E5 		str	r2, [r3, #64]
 274:../cyfxtx.c   ****     if (glBufferManager.usedStatus == 0)
 625              		.loc 1 274 0
 626 0490 6C309FE5 		ldr	r3, .L41
 627 0494 403093E5 		ldr	r3, [r3, #64]
 628 0498 000053E3 		cmp	r3, #0
 629 049c 0200001A 		bne	.L40
 275:../cyfxtx.c   ****     {
 276:../cyfxtx.c   ****         CyU3PMutexDestroy (&glBufferManager.lock);
 630              		.loc 1 276 0
 631 04a0 5C009FE5 		ldr	r0, .L41
 632 04a4 FEFFFFEB 		bl	_txe_mutex_delete
 277:../cyfxtx.c   ****         return;
 633              		.loc 1 277 0
 634 04a8 130000EA 		b	.L36
 635              	.L40:
 278:../cyfxtx.c   ****     }
 279:../cyfxtx.c   **** 
 280:../cyfxtx.c   ****     /* Initially mark all memory as available. If there are any status bits
 281:../cyfxtx.c   ****        beyond the valid memory range, mark these as unavailable. */
 282:../cyfxtx.c   ****     CyU3PMemSet ((uint8_t *)glBufferManager.usedStatus, 0, (size * 4));
 636              		.loc 1 282 0
 637 04ac 50309FE5 		ldr	r3, .L41
 638 04b0 402093E5 		ldr	r2, [r3, #64]
 639 04b4 0C301BE5 		ldr	r3, [fp, #-12]
 640 04b8 0331A0E1 		mov	r3, r3, asl #2
 641 04bc 0200A0E1 		mov	r0, r2
 642 04c0 0010A0E3 		mov	r1, #0
 643 04c4 0320A0E1 		mov	r2, r3
 644 04c8 FEFFFFEB 		bl	CyU3PMemSet
 283:../cyfxtx.c   ****     if ((CY_U3P_BUFFER_HEAP_SIZE / 32) & 31)
 284:../cyfxtx.c   ****     {
 285:../cyfxtx.c   ****         tmp = 32 - ((CY_U3P_BUFFER_HEAP_SIZE / 32) & 31);
 286:../cyfxtx.c   ****         glBufferManager.usedStatus[size - 1] = ~((1 << tmp) - 1);
 287:../cyfxtx.c   ****     }
 288:../cyfxtx.c   **** 
 289:../cyfxtx.c   ****     /* Initialize the start address and region size variables. */
 290:../cyfxtx.c   ****     glBufferManager.startAddr  = CY_U3P_BUFFER_HEAP_BASE;
 645              		.loc 1 290 0
 646 04cc 30309FE5 		ldr	r3, .L41
 647 04d0 30209FE5 		ldr	r2, .L41+4
 648 04d4 382083E5 		str	r2, [r3, #56]
 291:../cyfxtx.c   ****     glBufferManager.regionSize = CY_U3P_BUFFER_HEAP_SIZE;
 649              		.loc 1 291 0
 650 04d8 24309FE5 		ldr	r3, .L41
 651 04dc 0E29A0E3 		mov	r2, #229376
 652 04e0 3C2083E5 		str	r2, [r3, #60]
 292:../cyfxtx.c   ****     glBufferManager.statusSize = size;
 653              		.loc 1 292 0
 654 04e4 18309FE5 		ldr	r3, .L41
 655 04e8 0C201BE5 		ldr	r2, [fp, #-12]
 656 04ec 442083E5 		str	r2, [r3, #68]
 293:../cyfxtx.c   ****     glBufferManager.searchPos  = 0;
 657              		.loc 1 293 0
 658 04f0 0C309FE5 		ldr	r3, .L41
 659 04f4 0020A0E3 		mov	r2, #0
 660 04f8 482083E5 		str	r2, [r3, #72]
 661              	.L36:
 294:../cyfxtx.c   **** }
 662              		.loc 1 294 0
 663 04fc 04D04BE2 		sub	sp, fp, #4
 664              		@ sp needed
 665 0500 0088BDE8 		ldmfd	sp!, {fp, pc}
 666              	.L42:
 667              		.align	2
 668              	.L41:
 669 0504 00000000 		.word	glBufferManager
 670 0508 00000440 		.word	1074003968
 671              		.cfi_endproc
 672              	.LFE10:
 674              		.align	2
 675              		.global	CyU3PDmaBufferDeInit
 677              	CyU3PDmaBufferDeInit:
 678              	.LFB11:
 295:../cyfxtx.c   **** 
 296:../cyfxtx.c   **** /* This function shall be invoked by the API library 
 297:../cyfxtx.c   ****  * and should not be explicitly invoked.
 298:../cyfxtx.c   ****  */
 299:../cyfxtx.c   **** void
 300:../cyfxtx.c   **** CyU3PDmaBufferDeInit (
 301:../cyfxtx.c   ****         void)
 302:../cyfxtx.c   **** {
 679              		.loc 1 302 0
 680              		.cfi_startproc
 681              		@ args = 0, pretend = 0, frame = 8
 682              		@ frame_needed = 1, uses_anonymous_args = 0
 683 050c 00482DE9 		stmfd	sp!, {fp, lr}
 684              	.LCFI22:
 685              		.cfi_def_cfa_offset 8
 686              		.cfi_offset 11, -8
 687              		.cfi_offset 14, -4
 688 0510 04B08DE2 		add	fp, sp, #4
 689              	.LCFI23:
 690              		.cfi_def_cfa 11, 4
 691 0514 08D04DE2 		sub	sp, sp, #8
 303:../cyfxtx.c   ****     uint32_t status;
 304:../cyfxtx.c   **** 
 305:../cyfxtx.c   ****     /* Get the mutex lock. */
 306:../cyfxtx.c   ****     if (CyU3PThreadIdentify ())
 692              		.loc 1 306 0
 693 0518 FEFFFFEB 		bl	_tx_thread_identify
 694 051c 0030A0E1 		mov	r3, r0
 695 0520 000053E3 		cmp	r3, #0
 696 0524 0400000A 		beq	.L44
 307:../cyfxtx.c   ****     {
 308:../cyfxtx.c   ****         status = CyU3PMutexGet (&glBufferManager.lock, CYU3P_WAIT_FOREVER);
 697              		.loc 1 308 0
 698 0528 84009FE5 		ldr	r0, .L48
 699 052c 0010E0E3 		mvn	r1, #0
 700 0530 FEFFFFEB 		bl	_txe_mutex_get
 701 0534 08000BE5 		str	r0, [fp, #-8]
 702 0538 030000EA 		b	.L45
 703              	.L44:
 309:../cyfxtx.c   ****     }
 310:../cyfxtx.c   ****     else
 311:../cyfxtx.c   ****     {
 312:../cyfxtx.c   ****         status = CyU3PMutexGet (&glBufferManager.lock, CYU3P_NO_WAIT);
 704              		.loc 1 312 0
 705 053c 70009FE5 		ldr	r0, .L48
 706 0540 0010A0E3 		mov	r1, #0
 707 0544 FEFFFFEB 		bl	_txe_mutex_get
 708 0548 08000BE5 		str	r0, [fp, #-8]
 709              	.L45:
 313:../cyfxtx.c   ****     }
 314:../cyfxtx.c   **** 
 315:../cyfxtx.c   ****     if (status != CY_U3P_SUCCESS)
 710              		.loc 1 315 0
 711 054c 08301BE5 		ldr	r3, [fp, #-8]
 712 0550 000053E3 		cmp	r3, #0
 713 0554 0000000A 		beq	.L46
 316:../cyfxtx.c   ****     {
 317:../cyfxtx.c   ****         return;
 714              		.loc 1 317 0
 715 0558 130000EA 		b	.L43
 716              	.L46:
 318:../cyfxtx.c   ****     }
 319:../cyfxtx.c   **** 
 320:../cyfxtx.c   ****     /* Free memory and zero out variables. */
 321:../cyfxtx.c   ****     CyU3PMemFree (glBufferManager.usedStatus);
 717              		.loc 1 321 0
 718 055c 50309FE5 		ldr	r3, .L48
 719 0560 403093E5 		ldr	r3, [r3, #64]
 720 0564 0300A0E1 		mov	r0, r3
 721 0568 FEFFFFEB 		bl	CyU3PMemFree
 322:../cyfxtx.c   ****     glBufferManager.usedStatus = 0;
 722              		.loc 1 322 0
 723 056c 40309FE5 		ldr	r3, .L48
 724 0570 0020A0E3 		mov	r2, #0
 725 0574 402083E5 		str	r2, [r3, #64]
 323:../cyfxtx.c   ****     glBufferManager.startAddr  = 0;
 726              		.loc 1 323 0
 727 0578 34309FE5 		ldr	r3, .L48
 728 057c 0020A0E3 		mov	r2, #0
 729 0580 382083E5 		str	r2, [r3, #56]
 324:../cyfxtx.c   ****     glBufferManager.regionSize = 0;
 730              		.loc 1 324 0
 731 0584 28309FE5 		ldr	r3, .L48
 732 0588 0020A0E3 		mov	r2, #0
 733 058c 3C2083E5 		str	r2, [r3, #60]
 325:../cyfxtx.c   ****     glBufferManager.statusSize = 0;
 734              		.loc 1 325 0
 735 0590 1C309FE5 		ldr	r3, .L48
 736 0594 0020A0E3 		mov	r2, #0
 737 0598 442083E5 		str	r2, [r3, #68]
 326:../cyfxtx.c   **** 
 327:../cyfxtx.c   ****     /* Free up and destroy the mutex variable. */
 328:../cyfxtx.c   ****     CyU3PMutexPut (&glBufferManager.lock);
 738              		.loc 1 328 0
 739 059c 10009FE5 		ldr	r0, .L48
 740 05a0 FEFFFFEB 		bl	_txe_mutex_put
 329:../cyfxtx.c   ****     CyU3PMutexDestroy (&glBufferManager.lock);
 741              		.loc 1 329 0
 742 05a4 08009FE5 		ldr	r0, .L48
 743 05a8 FEFFFFEB 		bl	_txe_mutex_delete
 744              	.L43:
 330:../cyfxtx.c   **** }
 745              		.loc 1 330 0
 746 05ac 04D04BE2 		sub	sp, fp, #4
 747              		@ sp needed
 748 05b0 0088BDE8 		ldmfd	sp!, {fp, pc}
 749              	.L49:
 750              		.align	2
 751              	.L48:
 752 05b4 00000000 		.word	glBufferManager
 753              		.cfi_endproc
 754              	.LFE11:
 756              		.align	2
 758              	CyU3PDmaBufMgrSetStatus:
 759              	.LFB12:
 331:../cyfxtx.c   **** 
 332:../cyfxtx.c   **** /* Helper function for the DMA buffer manager. Used to set/clear
 333:../cyfxtx.c   ****    a set of status bits from the alloc/free functions. */
 334:../cyfxtx.c   **** static void
 335:../cyfxtx.c   **** CyU3PDmaBufMgrSetStatus (
 336:../cyfxtx.c   ****         uint32_t startPos,
 337:../cyfxtx.c   ****         uint32_t numBits,
 338:../cyfxtx.c   ****         CyBool_t value)
 339:../cyfxtx.c   **** {
 760              		.loc 1 339 0
 761              		.cfi_startproc
 762              		@ args = 0, pretend = 0, frame = 32
 763              		@ frame_needed = 1, uses_anonymous_args = 0
 764              		@ link register save eliminated.
 765 05b8 04B02DE5 		str	fp, [sp, #-4]!
 766              	.LCFI24:
 767              		.cfi_def_cfa_offset 4
 768              		.cfi_offset 11, -4
 769 05bc 00B08DE2 		add	fp, sp, #0
 770              	.LCFI25:
 771              		.cfi_def_cfa_register 11
 772 05c0 24D04DE2 		sub	sp, sp, #36
 773 05c4 18000BE5 		str	r0, [fp, #-24]
 774 05c8 1C100BE5 		str	r1, [fp, #-28]
 775 05cc 20200BE5 		str	r2, [fp, #-32]
 340:../cyfxtx.c   ****     uint32_t wordnum  = (startPos >> 5);
 776              		.loc 1 340 0
 777 05d0 18301BE5 		ldr	r3, [fp, #-24]
 778 05d4 A332A0E1 		mov	r3, r3, lsr #5
 779 05d8 08300BE5 		str	r3, [fp, #-8]
 341:../cyfxtx.c   ****     uint32_t startbit, endbit, mask;
 342:../cyfxtx.c   **** 
 343:../cyfxtx.c   ****     startbit = (startPos & 31);
 780              		.loc 1 343 0
 781 05dc 18301BE5 		ldr	r3, [fp, #-24]
 782 05e0 1F3003E2 		and	r3, r3, #31
 783 05e4 0C300BE5 		str	r3, [fp, #-12]
 344:../cyfxtx.c   ****     endbit   = CY_U3P_MIN (32, startbit + numBits);
 784              		.loc 1 344 0
 785 05e8 0C201BE5 		ldr	r2, [fp, #-12]
 786 05ec 1C301BE5 		ldr	r3, [fp, #-28]
 787 05f0 033082E0 		add	r3, r2, r3
 788 05f4 200053E3 		cmp	r3, #32
 789 05f8 2030A023 		movcs	r3, #32
 790 05fc 10300BE5 		str	r3, [fp, #-16]
 345:../cyfxtx.c   **** 
 346:../cyfxtx.c   ****     /* Compute a mask that has a 1 at all bit positions to be altered. */
 347:../cyfxtx.c   ****     mask  = (endbit == 32) ? 0xFFFFFFFFU : ((uint32_t)(1 << endbit) - 1);
 791              		.loc 1 347 0
 792 0600 10301BE5 		ldr	r3, [fp, #-16]
 793 0604 200053E3 		cmp	r3, #32
 794 0608 0400000A 		beq	.L51
 795              		.loc 1 347 0 is_stmt 0 discriminator 1
 796 060c 10301BE5 		ldr	r3, [fp, #-16]
 797 0610 0120A0E3 		mov	r2, #1
 798 0614 1233A0E1 		mov	r3, r2, asl r3
 799 0618 013043E2 		sub	r3, r3, #1
 800 061c 000000EA 		b	.L52
 801              	.L51:
 802              		.loc 1 347 0 discriminator 2
 803 0620 0030E0E3 		mvn	r3, #0
 804              	.L52:
 805              		.loc 1 347 0 discriminator 3
 806 0624 14300BE5 		str	r3, [fp, #-20]
 348:../cyfxtx.c   ****     mask -= ((1 << startbit) - 1);
 807              		.loc 1 348 0 is_stmt 1 discriminator 3
 808 0628 0C301BE5 		ldr	r3, [fp, #-12]
 809 062c 0120A0E3 		mov	r2, #1
 810 0630 1233A0E1 		mov	r3, r2, asl r3
 811 0634 14201BE5 		ldr	r2, [fp, #-20]
 812 0638 023063E0 		rsb	r3, r3, r2
 813 063c 013083E2 		add	r3, r3, #1
 814 0640 14300BE5 		str	r3, [fp, #-20]
 349:../cyfxtx.c   **** 
 350:../cyfxtx.c   ****     /* Repeatedly go through the array and update each 32 bit word as required. */
 351:../cyfxtx.c   ****     while (numBits)
 815              		.loc 1 351 0 discriminator 3
 816 0644 3C0000EA 		b	.L53
 817              	.L57:
 352:../cyfxtx.c   ****     {
 353:../cyfxtx.c   ****         if (value)
 818              		.loc 1 353 0
 819 0648 20301BE5 		ldr	r3, [fp, #-32]
 820 064c 000053E3 		cmp	r3, #0
 821 0650 0E00000A 		beq	.L54
 354:../cyfxtx.c   ****         {
 355:../cyfxtx.c   ****             glBufferManager.usedStatus[wordnum] |= mask;
 822              		.loc 1 355 0
 823 0654 F8309FE5 		ldr	r3, .L58
 824 0658 402093E5 		ldr	r2, [r3, #64]
 825 065c 08301BE5 		ldr	r3, [fp, #-8]
 826 0660 0331A0E1 		mov	r3, r3, asl #2
 827 0664 033082E0 		add	r3, r2, r3
 828 0668 E4209FE5 		ldr	r2, .L58
 829 066c 401092E5 		ldr	r1, [r2, #64]
 830 0670 08201BE5 		ldr	r2, [fp, #-8]
 831 0674 0221A0E1 		mov	r2, r2, asl #2
 832 0678 022081E0 		add	r2, r1, r2
 833 067c 001092E5 		ldr	r1, [r2]
 834 0680 14201BE5 		ldr	r2, [fp, #-20]
 835 0684 022081E1 		orr	r2, r1, r2
 836 0688 002083E5 		str	r2, [r3]
 837 068c 0E0000EA 		b	.L55
 838              	.L54:
 356:../cyfxtx.c   ****         }
 357:../cyfxtx.c   ****         else
 358:../cyfxtx.c   ****         {
 359:../cyfxtx.c   ****             glBufferManager.usedStatus[wordnum] &= ~mask;
 839              		.loc 1 359 0
 840 0690 BC309FE5 		ldr	r3, .L58
 841 0694 402093E5 		ldr	r2, [r3, #64]
 842 0698 08301BE5 		ldr	r3, [fp, #-8]
 843 069c 0331A0E1 		mov	r3, r3, asl #2
 844 06a0 033082E0 		add	r3, r2, r3
 845 06a4 A8209FE5 		ldr	r2, .L58
 846 06a8 401092E5 		ldr	r1, [r2, #64]
 847 06ac 08201BE5 		ldr	r2, [fp, #-8]
 848 06b0 0221A0E1 		mov	r2, r2, asl #2
 849 06b4 022081E0 		add	r2, r1, r2
 850 06b8 001092E5 		ldr	r1, [r2]
 851 06bc 14201BE5 		ldr	r2, [fp, #-20]
 852 06c0 0220E0E1 		mvn	r2, r2
 853 06c4 022001E0 		and	r2, r1, r2
 854 06c8 002083E5 		str	r2, [r3]
 855              	.L55:
 360:../cyfxtx.c   ****         }
 361:../cyfxtx.c   **** 
 362:../cyfxtx.c   ****         wordnum++;
 856              		.loc 1 362 0
 857 06cc 08301BE5 		ldr	r3, [fp, #-8]
 858 06d0 013083E2 		add	r3, r3, #1
 859 06d4 08300BE5 		str	r3, [fp, #-8]
 363:../cyfxtx.c   ****         numBits -= (endbit - startbit);
 860              		.loc 1 363 0
 861 06d8 0C201BE5 		ldr	r2, [fp, #-12]
 862 06dc 10301BE5 		ldr	r3, [fp, #-16]
 863 06e0 023063E0 		rsb	r3, r3, r2
 864 06e4 1C201BE5 		ldr	r2, [fp, #-28]
 865 06e8 033082E0 		add	r3, r2, r3
 866 06ec 1C300BE5 		str	r3, [fp, #-28]
 364:../cyfxtx.c   ****         if (numBits >= 32)
 867              		.loc 1 364 0
 868 06f0 1C301BE5 		ldr	r3, [fp, #-28]
 869 06f4 1F0053E3 		cmp	r3, #31
 870 06f8 0600009A 		bls	.L56
 365:../cyfxtx.c   ****         {
 366:../cyfxtx.c   ****             startbit = 0;
 871              		.loc 1 366 0
 872 06fc 0030A0E3 		mov	r3, #0
 873 0700 0C300BE5 		str	r3, [fp, #-12]
 367:../cyfxtx.c   ****             endbit   = 32;
 874              		.loc 1 367 0
 875 0704 2030A0E3 		mov	r3, #32
 876 0708 10300BE5 		str	r3, [fp, #-16]
 368:../cyfxtx.c   ****             mask     = 0xFFFFFFFFU;
 877              		.loc 1 368 0
 878 070c 0030E0E3 		mvn	r3, #0
 879 0710 14300BE5 		str	r3, [fp, #-20]
 880 0714 080000EA 		b	.L53
 881              	.L56:
 369:../cyfxtx.c   ****         }
 370:../cyfxtx.c   ****         else
 371:../cyfxtx.c   ****         {
 372:../cyfxtx.c   ****             startbit = 0;
 882              		.loc 1 372 0
 883 0718 0030A0E3 		mov	r3, #0
 884 071c 0C300BE5 		str	r3, [fp, #-12]
 373:../cyfxtx.c   ****             endbit   = numBits;
 885              		.loc 1 373 0
 886 0720 1C301BE5 		ldr	r3, [fp, #-28]
 887 0724 10300BE5 		str	r3, [fp, #-16]
 374:../cyfxtx.c   ****             mask     = ((uint32_t)(1 << numBits) - 1);
 888              		.loc 1 374 0
 889 0728 1C301BE5 		ldr	r3, [fp, #-28]
 890 072c 0120A0E3 		mov	r2, #1
 891 0730 1233A0E1 		mov	r3, r2, asl r3
 892 0734 013043E2 		sub	r3, r3, #1
 893 0738 14300BE5 		str	r3, [fp, #-20]
 894              	.L53:
 351:../cyfxtx.c   ****     {
 895              		.loc 1 351 0 discriminator 1
 896 073c 1C301BE5 		ldr	r3, [fp, #-28]
 897 0740 000053E3 		cmp	r3, #0
 898 0744 BFFFFF1A 		bne	.L57
 375:../cyfxtx.c   ****         }
 376:../cyfxtx.c   ****     }
 377:../cyfxtx.c   **** }
 899              		.loc 1 377 0
 900 0748 00D04BE2 		sub	sp, fp, #0
 901              		@ sp needed
 902 074c 04B09DE4 		ldr	fp, [sp], #4
 903 0750 1EFF2FE1 		bx	lr
 904              	.L59:
 905              		.align	2
 906              	.L58:
 907 0754 00000000 		.word	glBufferManager
 908              		.cfi_endproc
 909              	.LFE12:
 911              		.align	2
 912              		.global	CyU3PDmaBufferAlloc
 914              	CyU3PDmaBufferAlloc:
 915              	.LFB13:
 378:../cyfxtx.c   **** 
 379:../cyfxtx.c   **** /* This function shall be invoked from the DMA module for buffer allocation */
 380:../cyfxtx.c   **** void *
 381:../cyfxtx.c   **** CyU3PDmaBufferAlloc (
 382:../cyfxtx.c   ****         uint16_t size)
 383:../cyfxtx.c   **** {
 916              		.loc 1 383 0
 917              		.cfi_startproc
 918              		@ args = 0, pretend = 0, frame = 32
 919              		@ frame_needed = 1, uses_anonymous_args = 0
 920 0758 00482DE9 		stmfd	sp!, {fp, lr}
 921              	.LCFI26:
 922              		.cfi_def_cfa_offset 8
 923              		.cfi_offset 11, -8
 924              		.cfi_offset 14, -4
 925 075c 04B08DE2 		add	fp, sp, #4
 926              	.LCFI27:
 927              		.cfi_def_cfa 11, 4
 928 0760 20D04DE2 		sub	sp, sp, #32
 929 0764 0030A0E1 		mov	r3, r0
 930 0768 BE314BE1 		strh	r3, [fp, #-30]	@ movhi
 384:../cyfxtx.c   ****     uint32_t tmp;
 385:../cyfxtx.c   ****     uint32_t wordnum, bitnum;
 386:../cyfxtx.c   ****     uint32_t count, start = 0;
 931              		.loc 1 386 0
 932 076c 0030A0E3 		mov	r3, #0
 933 0770 18300BE5 		str	r3, [fp, #-24]
 387:../cyfxtx.c   ****     void *ptr = 0;
 934              		.loc 1 387 0
 935 0774 0030A0E3 		mov	r3, #0
 936 0778 1C300BE5 		str	r3, [fp, #-28]
 388:../cyfxtx.c   **** 
 389:../cyfxtx.c   ****     /* Get the lock for the buffer manager. */
 390:../cyfxtx.c   ****     if (CyU3PThreadIdentify ())
 937              		.loc 1 390 0
 938 077c FEFFFFEB 		bl	_tx_thread_identify
 939 0780 0030A0E1 		mov	r3, r0
 940 0784 000053E3 		cmp	r3, #0
 941 0788 0400000A 		beq	.L61
 391:../cyfxtx.c   ****     {
 392:../cyfxtx.c   ****         tmp = CyU3PMutexGet (&glBufferManager.lock, CY_U3P_BUFFER_ALLOC_TIMEOUT);
 942              		.loc 1 392 0
 943 078c 20029FE5 		ldr	r0, .L76
 944 0790 0A10A0E3 		mov	r1, #10
 945 0794 FEFFFFEB 		bl	_txe_mutex_get
 946 0798 08000BE5 		str	r0, [fp, #-8]
 947 079c 030000EA 		b	.L62
 948              	.L61:
 393:../cyfxtx.c   ****     }
 394:../cyfxtx.c   ****     else
 395:../cyfxtx.c   ****     {
 396:../cyfxtx.c   ****         tmp = CyU3PMutexGet (&glBufferManager.lock, CYU3P_NO_WAIT);
 949              		.loc 1 396 0
 950 07a0 0C029FE5 		ldr	r0, .L76
 951 07a4 0010A0E3 		mov	r1, #0
 952 07a8 FEFFFFEB 		bl	_txe_mutex_get
 953 07ac 08000BE5 		str	r0, [fp, #-8]
 954              	.L62:
 397:../cyfxtx.c   ****     }
 398:../cyfxtx.c   **** 
 399:../cyfxtx.c   ****     if (tmp != CY_U3P_SUCCESS)
 955              		.loc 1 399 0
 956 07b0 08301BE5 		ldr	r3, [fp, #-8]
 957 07b4 000053E3 		cmp	r3, #0
 958 07b8 0100000A 		beq	.L63
 400:../cyfxtx.c   ****     {
 401:../cyfxtx.c   ****         return ptr;
 959              		.loc 1 401 0
 960 07bc 1C301BE5 		ldr	r3, [fp, #-28]
 961 07c0 780000EA 		b	.L64
 962              	.L63:
 402:../cyfxtx.c   ****     }
 403:../cyfxtx.c   **** 
 404:../cyfxtx.c   ****     /* Make sure the buffer manager has been initialized. */
 405:../cyfxtx.c   ****     if ((glBufferManager.startAddr == 0) || (glBufferManager.regionSize == 0))
 963              		.loc 1 405 0
 964 07c4 E8319FE5 		ldr	r3, .L76
 965 07c8 383093E5 		ldr	r3, [r3, #56]
 966 07cc 000053E3 		cmp	r3, #0
 967 07d0 0300000A 		beq	.L65
 968              		.loc 1 405 0 is_stmt 0 discriminator 1
 969 07d4 D8319FE5 		ldr	r3, .L76
 970 07d8 3C3093E5 		ldr	r3, [r3, #60]
 971 07dc 000053E3 		cmp	r3, #0
 972 07e0 0300001A 		bne	.L66
 973              	.L65:
 406:../cyfxtx.c   ****     {
 407:../cyfxtx.c   ****         CyU3PMutexPut (&glBufferManager.lock);
 974              		.loc 1 407 0 is_stmt 1
 975 07e4 C8019FE5 		ldr	r0, .L76
 976 07e8 FEFFFFEB 		bl	_txe_mutex_put
 408:../cyfxtx.c   ****         return ptr;
 977              		.loc 1 408 0
 978 07ec 1C301BE5 		ldr	r3, [fp, #-28]
 979 07f0 6C0000EA 		b	.L64
 980              	.L66:
 409:../cyfxtx.c   ****     }
 410:../cyfxtx.c   **** 
 411:../cyfxtx.c   ****     /* Find the number of 32 byte chunks required. The minimum size that can be handled is
 412:../cyfxtx.c   ****        64 bytes. */
 413:../cyfxtx.c   ****     size = (size <= 32) ? 2 : (size + 31) / 32;
 981              		.loc 1 413 0
 982 07f4 BE315BE1 		ldrh	r3, [fp, #-30]
 983 07f8 200053E3 		cmp	r3, #32
 984 07fc 0800009A 		bls	.L67
 985              		.loc 1 413 0 is_stmt 0 discriminator 1
 986 0800 BE315BE1 		ldrh	r3, [fp, #-30]
 987 0804 1F3083E2 		add	r3, r3, #31
 988 0808 1F2083E2 		add	r2, r3, #31
 989 080c 000053E3 		cmp	r3, #0
 990 0810 0230A0B1 		movlt	r3, r2
 991 0814 C332A0E1 		mov	r3, r3, asr #5
 992 0818 0338A0E1 		mov	r3, r3, asl #16
 993 081c 2338A0E1 		mov	r3, r3, lsr #16
 994 0820 000000EA 		b	.L68
 995              	.L67:
 996              		.loc 1 413 0 discriminator 2
 997 0824 0230A0E3 		mov	r3, #2
 998              	.L68:
 999              		.loc 1 413 0 discriminator 3
 1000 0828 BE314BE1 		strh	r3, [fp, #-30]	@ movhi
 414:../cyfxtx.c   **** 
 415:../cyfxtx.c   ****     /* Search through the status array to find the first block that fits the need. */
 416:../cyfxtx.c   ****     wordnum = glBufferManager.searchPos;
 1001              		.loc 1 416 0 is_stmt 1 discriminator 3
 1002 082c 80319FE5 		ldr	r3, .L76
 1003 0830 483093E5 		ldr	r3, [r3, #72]
 1004 0834 0C300BE5 		str	r3, [fp, #-12]
 417:../cyfxtx.c   ****     bitnum  = 0;
 1005              		.loc 1 417 0 discriminator 3
 1006 0838 0030A0E3 		mov	r3, #0
 1007 083c 10300BE5 		str	r3, [fp, #-16]
 418:../cyfxtx.c   ****     count   = 0;
 1008              		.loc 1 418 0 discriminator 3
 1009 0840 0030A0E3 		mov	r3, #0
 1010 0844 14300BE5 		str	r3, [fp, #-20]
 419:../cyfxtx.c   ****     tmp     = 0;
 1011              		.loc 1 419 0 discriminator 3
 1012 0848 0030A0E3 		mov	r3, #0
 1013 084c 08300BE5 		str	r3, [fp, #-8]
 420:../cyfxtx.c   **** 
 421:../cyfxtx.c   ****     /* Stop searching once we have checked all of the words. */
 422:../cyfxtx.c   ****     while (tmp < glBufferManager.statusSize)
 1014              		.loc 1 422 0 discriminator 3
 1015 0850 3A0000EA 		b	.L69
 1016              	.L74:
 423:../cyfxtx.c   ****     {
 424:../cyfxtx.c   ****         if ((glBufferManager.usedStatus[wordnum] & (1 << bitnum)) == 0)
 1017              		.loc 1 424 0
 1018 0854 58319FE5 		ldr	r3, .L76
 1019 0858 402093E5 		ldr	r2, [r3, #64]
 1020 085c 0C301BE5 		ldr	r3, [fp, #-12]
 1021 0860 0331A0E1 		mov	r3, r3, asl #2
 1022 0864 033082E0 		add	r3, r2, r3
 1023 0868 002093E5 		ldr	r2, [r3]
 1024 086c 10301BE5 		ldr	r3, [fp, #-16]
 1025 0870 0110A0E3 		mov	r1, #1
 1026 0874 1133A0E1 		mov	r3, r1, asl r3
 1027 0878 033002E0 		and	r3, r2, r3
 1028 087c 000053E3 		cmp	r3, #0
 1029 0880 1500001A 		bne	.L70
 425:../cyfxtx.c   ****         {
 426:../cyfxtx.c   ****             if (count == 0)
 1030              		.loc 1 426 0
 1031 0884 14301BE5 		ldr	r3, [fp, #-20]
 1032 0888 000053E3 		cmp	r3, #0
 1033 088c 0500001A 		bne	.L71
 427:../cyfxtx.c   ****             {
 428:../cyfxtx.c   ****                 start = (wordnum << 5) + bitnum + 1;
 1034              		.loc 1 428 0
 1035 0890 0C301BE5 		ldr	r3, [fp, #-12]
 1036 0894 8322A0E1 		mov	r2, r3, asl #5
 1037 0898 10301BE5 		ldr	r3, [fp, #-16]
 1038 089c 033082E0 		add	r3, r2, r3
 1039 08a0 013083E2 		add	r3, r3, #1
 1040 08a4 18300BE5 		str	r3, [fp, #-24]
 1041              	.L71:
 429:../cyfxtx.c   ****             }
 430:../cyfxtx.c   ****             count++;
 1042              		.loc 1 430 0
 1043 08a8 14301BE5 		ldr	r3, [fp, #-20]
 1044 08ac 013083E2 		add	r3, r3, #1
 1045 08b0 14300BE5 		str	r3, [fp, #-20]
 431:../cyfxtx.c   ****             if (count == (size + 1))
 1046              		.loc 1 431 0
 1047 08b4 BE315BE1 		ldrh	r3, [fp, #-30]
 1048 08b8 013083E2 		add	r3, r3, #1
 1049 08bc 0320A0E1 		mov	r2, r3
 1050 08c0 14301BE5 		ldr	r3, [fp, #-20]
 1051 08c4 030052E1 		cmp	r2, r3
 1052 08c8 0500001A 		bne	.L72
 432:../cyfxtx.c   ****             {
 433:../cyfxtx.c   ****                 /* The last bit corresponding to the allocated memory is left as zero.
 434:../cyfxtx.c   ****                    This allows us to identify the end of the allocated block while freeing
 435:../cyfxtx.c   ****                    the memory. We need to search for one additional zero while allocating
 436:../cyfxtx.c   ****                    to account for this hack. */
 437:../cyfxtx.c   ****                 glBufferManager.searchPos = wordnum;
 1053              		.loc 1 437 0
 1054 08cc E0309FE5 		ldr	r3, .L76
 1055 08d0 0C201BE5 		ldr	r2, [fp, #-12]
 1056 08d4 482083E5 		str	r2, [r3, #72]
 438:../cyfxtx.c   ****                 break;
 1057              		.loc 1 438 0
 1058 08d8 1D0000EA 		b	.L73
 1059              	.L70:
 439:../cyfxtx.c   ****             }
 440:../cyfxtx.c   ****         }
 441:../cyfxtx.c   ****         else
 442:../cyfxtx.c   ****         {
 443:../cyfxtx.c   ****             count = 0;
 1060              		.loc 1 443 0
 1061 08dc 0030A0E3 		mov	r3, #0
 1062 08e0 14300BE5 		str	r3, [fp, #-20]
 1063              	.L72:
 444:../cyfxtx.c   ****         }
 445:../cyfxtx.c   **** 
 446:../cyfxtx.c   ****         bitnum++;
 1064              		.loc 1 446 0
 1065 08e4 10301BE5 		ldr	r3, [fp, #-16]
 1066 08e8 013083E2 		add	r3, r3, #1
 1067 08ec 10300BE5 		str	r3, [fp, #-16]
 447:../cyfxtx.c   ****         if (bitnum == 32)
 1068              		.loc 1 447 0
 1069 08f0 10301BE5 		ldr	r3, [fp, #-16]
 1070 08f4 200053E3 		cmp	r3, #32
 1071 08f8 1000001A 		bne	.L69
 448:../cyfxtx.c   ****         {
 449:../cyfxtx.c   ****             bitnum = 0;
 1072              		.loc 1 449 0
 1073 08fc 0030A0E3 		mov	r3, #0
 1074 0900 10300BE5 		str	r3, [fp, #-16]
 450:../cyfxtx.c   ****             wordnum++;
 1075              		.loc 1 450 0
 1076 0904 0C301BE5 		ldr	r3, [fp, #-12]
 1077 0908 013083E2 		add	r3, r3, #1
 1078 090c 0C300BE5 		str	r3, [fp, #-12]
 451:../cyfxtx.c   ****             tmp++;
 1079              		.loc 1 451 0
 1080 0910 08301BE5 		ldr	r3, [fp, #-8]
 1081 0914 013083E2 		add	r3, r3, #1
 1082 0918 08300BE5 		str	r3, [fp, #-8]
 452:../cyfxtx.c   ****             if (wordnum == glBufferManager.statusSize)
 1083              		.loc 1 452 0
 1084 091c 90309FE5 		ldr	r3, .L76
 1085 0920 442093E5 		ldr	r2, [r3, #68]
 1086 0924 0C301BE5 		ldr	r3, [fp, #-12]
 1087 0928 030052E1 		cmp	r2, r3
 1088 092c 0300001A 		bne	.L69
 453:../cyfxtx.c   ****             {
 454:../cyfxtx.c   ****                 /* Wrap back to the top of the array. */
 455:../cyfxtx.c   ****                 wordnum = 0;
 1089              		.loc 1 455 0
 1090 0930 0030A0E3 		mov	r3, #0
 1091 0934 0C300BE5 		str	r3, [fp, #-12]
 456:../cyfxtx.c   ****                 count   = 0;
 1092              		.loc 1 456 0
 1093 0938 0030A0E3 		mov	r3, #0
 1094 093c 14300BE5 		str	r3, [fp, #-20]
 1095              	.L69:
 422:../cyfxtx.c   ****     {
 1096              		.loc 1 422 0 discriminator 1
 1097 0940 6C309FE5 		ldr	r3, .L76
 1098 0944 442093E5 		ldr	r2, [r3, #68]
 1099 0948 08301BE5 		ldr	r3, [fp, #-8]
 1100 094c 030052E1 		cmp	r2, r3
 1101 0950 BFFFFF8A 		bhi	.L74
 1102              	.L73:
 457:../cyfxtx.c   ****             }
 458:../cyfxtx.c   ****         }
 459:../cyfxtx.c   ****     }
 460:../cyfxtx.c   **** 
 461:../cyfxtx.c   ****     if (count == (size + 1))
 1103              		.loc 1 461 0
 1104 0954 BE315BE1 		ldrh	r3, [fp, #-30]
 1105 0958 013083E2 		add	r3, r3, #1
 1106 095c 0320A0E1 		mov	r2, r3
 1107 0960 14301BE5 		ldr	r3, [fp, #-20]
 1108 0964 030052E1 		cmp	r2, r3
 1109 0968 0B00001A 		bne	.L75
 462:../cyfxtx.c   ****     {
 463:../cyfxtx.c   ****         /* Mark the memory region identified as occupied and return the pointer. */
 464:../cyfxtx.c   ****         CyU3PDmaBufMgrSetStatus (start, size - 1, CyTrue);
 1110              		.loc 1 464 0
 1111 096c BE315BE1 		ldrh	r3, [fp, #-30]
 1112 0970 013043E2 		sub	r3, r3, #1
 1113 0974 18001BE5 		ldr	r0, [fp, #-24]
 1114 0978 0310A0E1 		mov	r1, r3
 1115 097c 0120A0E3 		mov	r2, #1
 1116 0980 0CFFFFEB 		bl	CyU3PDmaBufMgrSetStatus
 465:../cyfxtx.c   ****         ptr = (void *)(glBufferManager.startAddr + (start << 5));
 1117              		.loc 1 465 0
 1118 0984 28309FE5 		ldr	r3, .L76
 1119 0988 382093E5 		ldr	r2, [r3, #56]
 1120 098c 18301BE5 		ldr	r3, [fp, #-24]
 1121 0990 8332A0E1 		mov	r3, r3, asl #5
 1122 0994 033082E0 		add	r3, r2, r3
 1123 0998 1C300BE5 		str	r3, [fp, #-28]
 1124              	.L75:
 466:../cyfxtx.c   ****     }
 467:../cyfxtx.c   **** 
 468:../cyfxtx.c   ****     CyU3PMutexPut (&glBufferManager.lock);
 1125              		.loc 1 468 0
 1126 099c 10009FE5 		ldr	r0, .L76
 1127 09a0 FEFFFFEB 		bl	_txe_mutex_put
 469:../cyfxtx.c   ****     return (ptr);
 1128              		.loc 1 469 0
 1129 09a4 1C301BE5 		ldr	r3, [fp, #-28]
 1130              	.L64:
 470:../cyfxtx.c   **** }
 1131              		.loc 1 470 0
 1132 09a8 0300A0E1 		mov	r0, r3
 1133 09ac 04D04BE2 		sub	sp, fp, #4
 1134              		@ sp needed
 1135 09b0 0088BDE8 		ldmfd	sp!, {fp, pc}
 1136              	.L77:
 1137              		.align	2
 1138              	.L76:
 1139 09b4 00000000 		.word	glBufferManager
 1140              		.cfi_endproc
 1141              	.LFE13:
 1143              		.align	2
 1144              		.global	CyU3PDmaBufferFree
 1146              	CyU3PDmaBufferFree:
 1147              	.LFB14:
 471:../cyfxtx.c   **** 
 472:../cyfxtx.c   **** /* This function shall be invoked from the DMA module for buffer de-allocation */
 473:../cyfxtx.c   **** int
 474:../cyfxtx.c   **** CyU3PDmaBufferFree (
 475:../cyfxtx.c   ****         void *buffer)
 476:../cyfxtx.c   **** {
 1148              		.loc 1 476 0
 1149              		.cfi_startproc
 1150              		@ args = 0, pretend = 0, frame = 32
 1151              		@ frame_needed = 1, uses_anonymous_args = 0
 1152 09b8 00482DE9 		stmfd	sp!, {fp, lr}
 1153              	.LCFI28:
 1154              		.cfi_def_cfa_offset 8
 1155              		.cfi_offset 11, -8
 1156              		.cfi_offset 14, -4
 1157 09bc 04B08DE2 		add	fp, sp, #4
 1158              	.LCFI29:
 1159              		.cfi_def_cfa 11, 4
 1160 09c0 20D04DE2 		sub	sp, sp, #32
 1161 09c4 20000BE5 		str	r0, [fp, #-32]
 477:../cyfxtx.c   ****     uint32_t status, start, count;
 478:../cyfxtx.c   ****     uint32_t wordnum, bitnum;
 479:../cyfxtx.c   ****     int      retVal = -1;
 1162              		.loc 1 479 0
 1163 09c8 0030E0E3 		mvn	r3, #0
 1164 09cc 18300BE5 		str	r3, [fp, #-24]
 480:../cyfxtx.c   **** 
 481:../cyfxtx.c   ****     /* Get the lock for the buffer manager. */
 482:../cyfxtx.c   ****     if (CyU3PThreadIdentify ())
 1165              		.loc 1 482 0
 1166 09d0 FEFFFFEB 		bl	_tx_thread_identify
 1167 09d4 0030A0E1 		mov	r3, r0
 1168 09d8 000053E3 		cmp	r3, #0
 1169 09dc 0400000A 		beq	.L79
 483:../cyfxtx.c   ****     {
 484:../cyfxtx.c   ****         status = CyU3PMutexGet (&glBufferManager.lock, CY_U3P_BUFFER_ALLOC_TIMEOUT);
 1170              		.loc 1 484 0
 1171 09e0 60019FE5 		ldr	r0, .L87
 1172 09e4 0A10A0E3 		mov	r1, #10
 1173 09e8 FEFFFFEB 		bl	_txe_mutex_get
 1174 09ec 08000BE5 		str	r0, [fp, #-8]
 1175 09f0 030000EA 		b	.L80
 1176              	.L79:
 485:../cyfxtx.c   ****     }
 486:../cyfxtx.c   ****     else
 487:../cyfxtx.c   ****     {
 488:../cyfxtx.c   ****         status = CyU3PMutexGet (&glBufferManager.lock, CYU3P_NO_WAIT);
 1177              		.loc 1 488 0
 1178 09f4 4C019FE5 		ldr	r0, .L87
 1179 09f8 0010A0E3 		mov	r1, #0
 1180 09fc FEFFFFEB 		bl	_txe_mutex_get
 1181 0a00 08000BE5 		str	r0, [fp, #-8]
 1182              	.L80:
 489:../cyfxtx.c   ****     }
 490:../cyfxtx.c   **** 
 491:../cyfxtx.c   ****     if (status != CY_U3P_SUCCESS)
 1183              		.loc 1 491 0
 1184 0a04 08301BE5 		ldr	r3, [fp, #-8]
 1185 0a08 000053E3 		cmp	r3, #0
 1186 0a0c 0100000A 		beq	.L81
 492:../cyfxtx.c   ****     {
 493:../cyfxtx.c   ****         return retVal;
 1187              		.loc 1 493 0
 1188 0a10 18301BE5 		ldr	r3, [fp, #-24]
 1189 0a14 480000EA 		b	.L82
 1190              	.L81:
 494:../cyfxtx.c   ****     }
 495:../cyfxtx.c   **** 
 496:../cyfxtx.c   ****     /* If the buffer address is within the range specified, count the number of consecutive ones an
 497:../cyfxtx.c   ****        clear them. */
 498:../cyfxtx.c   ****     start = (uint32_t)buffer;
 1191              		.loc 1 498 0
 1192 0a18 20301BE5 		ldr	r3, [fp, #-32]
 1193 0a1c 1C300BE5 		str	r3, [fp, #-28]
 499:../cyfxtx.c   ****     if ((start > glBufferManager.startAddr) && (start < (glBufferManager.startAddr + glBufferManage
 1194              		.loc 1 499 0
 1195 0a20 20319FE5 		ldr	r3, .L87
 1196 0a24 382093E5 		ldr	r2, [r3, #56]
 1197 0a28 1C301BE5 		ldr	r3, [fp, #-28]
 1198 0a2c 030052E1 		cmp	r2, r3
 1199 0a30 3E00002A 		bcs	.L83
 1200              		.loc 1 499 0 is_stmt 0 discriminator 1
 1201 0a34 0C319FE5 		ldr	r3, .L87
 1202 0a38 382093E5 		ldr	r2, [r3, #56]
 1203 0a3c 04319FE5 		ldr	r3, .L87
 1204 0a40 3C3093E5 		ldr	r3, [r3, #60]
 1205 0a44 032082E0 		add	r2, r2, r3
 1206 0a48 1C301BE5 		ldr	r3, [fp, #-28]
 1207 0a4c 030052E1 		cmp	r2, r3
 1208 0a50 3600009A 		bls	.L83
 500:../cyfxtx.c   ****     {
 501:../cyfxtx.c   ****         start = ((start - glBufferManager.startAddr) >> 5);
 1209              		.loc 1 501 0 is_stmt 1
 1210 0a54 EC309FE5 		ldr	r3, .L87
 1211 0a58 383093E5 		ldr	r3, [r3, #56]
 1212 0a5c 1C201BE5 		ldr	r2, [fp, #-28]
 1213 0a60 023063E0 		rsb	r3, r3, r2
 1214 0a64 A332A0E1 		mov	r3, r3, lsr #5
 1215 0a68 1C300BE5 		str	r3, [fp, #-28]
 502:../cyfxtx.c   **** 
 503:../cyfxtx.c   ****         wordnum = (start >> 5);
 1216              		.loc 1 503 0
 1217 0a6c 1C301BE5 		ldr	r3, [fp, #-28]
 1218 0a70 A332A0E1 		mov	r3, r3, lsr #5
 1219 0a74 10300BE5 		str	r3, [fp, #-16]
 504:../cyfxtx.c   ****         bitnum  = (start & 0x1F);
 1220              		.loc 1 504 0
 1221 0a78 1C301BE5 		ldr	r3, [fp, #-28]
 1222 0a7c 1F3003E2 		and	r3, r3, #31
 1223 0a80 14300BE5 		str	r3, [fp, #-20]
 505:../cyfxtx.c   ****         count   = 0;
 1224              		.loc 1 505 0
 1225 0a84 0030A0E3 		mov	r3, #0
 1226 0a88 0C300BE5 		str	r3, [fp, #-12]
 506:../cyfxtx.c   **** 
 507:../cyfxtx.c   ****         while ((wordnum < glBufferManager.statusSize) && ((glBufferManager.usedStatus[wordnum] & (1
 1227              		.loc 1 507 0
 1228 0a8c 0D0000EA 		b	.L84
 1229              	.L86:
 508:../cyfxtx.c   ****         {
 509:../cyfxtx.c   ****             count++;
 1230              		.loc 1 509 0
 1231 0a90 0C301BE5 		ldr	r3, [fp, #-12]
 1232 0a94 013083E2 		add	r3, r3, #1
 1233 0a98 0C300BE5 		str	r3, [fp, #-12]
 510:../cyfxtx.c   ****             bitnum++;
 1234              		.loc 1 510 0
 1235 0a9c 14301BE5 		ldr	r3, [fp, #-20]
 1236 0aa0 013083E2 		add	r3, r3, #1
 1237 0aa4 14300BE5 		str	r3, [fp, #-20]
 511:../cyfxtx.c   ****             if (bitnum == 32)
 1238              		.loc 1 511 0
 1239 0aa8 14301BE5 		ldr	r3, [fp, #-20]
 1240 0aac 200053E3 		cmp	r3, #32
 1241 0ab0 0400001A 		bne	.L84
 512:../cyfxtx.c   ****             {
 513:../cyfxtx.c   ****                 bitnum = 0;
 1242              		.loc 1 513 0
 1243 0ab4 0030A0E3 		mov	r3, #0
 1244 0ab8 14300BE5 		str	r3, [fp, #-20]
 514:../cyfxtx.c   ****                 wordnum++;
 1245              		.loc 1 514 0
 1246 0abc 10301BE5 		ldr	r3, [fp, #-16]
 1247 0ac0 013083E2 		add	r3, r3, #1
 1248 0ac4 10300BE5 		str	r3, [fp, #-16]
 1249              	.L84:
 507:../cyfxtx.c   ****         {
 1250              		.loc 1 507 0 discriminator 1
 1251 0ac8 78309FE5 		ldr	r3, .L87
 1252 0acc 442093E5 		ldr	r2, [r3, #68]
 1253 0ad0 10301BE5 		ldr	r3, [fp, #-16]
 1254 0ad4 030052E1 		cmp	r2, r3
 1255 0ad8 0B00009A 		bls	.L85
 507:../cyfxtx.c   ****         {
 1256              		.loc 1 507 0 is_stmt 0 discriminator 2
 1257 0adc 64309FE5 		ldr	r3, .L87
 1258 0ae0 402093E5 		ldr	r2, [r3, #64]
 1259 0ae4 10301BE5 		ldr	r3, [fp, #-16]
 1260 0ae8 0331A0E1 		mov	r3, r3, asl #2
 1261 0aec 033082E0 		add	r3, r2, r3
 1262 0af0 002093E5 		ldr	r2, [r3]
 1263 0af4 14301BE5 		ldr	r3, [fp, #-20]
 1264 0af8 0110A0E3 		mov	r1, #1
 1265 0afc 1133A0E1 		mov	r3, r1, asl r3
 1266 0b00 033002E0 		and	r3, r2, r3
 1267 0b04 000053E3 		cmp	r3, #0
 1268 0b08 E0FFFF1A 		bne	.L86
 1269              	.L85:
 515:../cyfxtx.c   ****             }
 516:../cyfxtx.c   ****         }
 517:../cyfxtx.c   **** 
 518:../cyfxtx.c   ****         CyU3PDmaBufMgrSetStatus (start, count, CyFalse);
 1270              		.loc 1 518 0 is_stmt 1
 1271 0b0c 1C001BE5 		ldr	r0, [fp, #-28]
 1272 0b10 0C101BE5 		ldr	r1, [fp, #-12]
 1273 0b14 0020A0E3 		mov	r2, #0
 1274 0b18 A6FEFFEB 		bl	CyU3PDmaBufMgrSetStatus
 519:../cyfxtx.c   **** 
 520:../cyfxtx.c   ****         /* Start the next buffer search at the top of the heap. This can help reduce fragmentation 
 521:../cyfxtx.c   ****            most of the heap is allocated and then freed as a whole. */
 522:../cyfxtx.c   ****         glBufferManager.searchPos = 0;
 1275              		.loc 1 522 0
 1276 0b1c 24309FE5 		ldr	r3, .L87
 1277 0b20 0020A0E3 		mov	r2, #0
 1278 0b24 482083E5 		str	r2, [r3, #72]
 523:../cyfxtx.c   ****         retVal = 0;
 1279              		.loc 1 523 0
 1280 0b28 0030A0E3 		mov	r3, #0
 1281 0b2c 18300BE5 		str	r3, [fp, #-24]
 1282              	.L83:
 524:../cyfxtx.c   ****     }
 525:../cyfxtx.c   **** 
 526:../cyfxtx.c   ****     /* Free the lock before we go. */
 527:../cyfxtx.c   ****     CyU3PMutexPut (&glBufferManager.lock);
 1283              		.loc 1 527 0
 1284 0b30 10009FE5 		ldr	r0, .L87
 1285 0b34 FEFFFFEB 		bl	_txe_mutex_put
 528:../cyfxtx.c   ****     return retVal;
 1286              		.loc 1 528 0
 1287 0b38 18301BE5 		ldr	r3, [fp, #-24]
 1288              	.L82:
 529:../cyfxtx.c   **** }
 1289              		.loc 1 529 0
 1290 0b3c 0300A0E1 		mov	r0, r3
 1291 0b40 04D04BE2 		sub	sp, fp, #4
 1292              		@ sp needed
 1293 0b44 0088BDE8 		ldmfd	sp!, {fp, pc}
 1294              	.L88:
 1295              		.align	2
 1296              	.L87:
 1297 0b48 00000000 		.word	glBufferManager
 1298              		.cfi_endproc
 1299              	.LFE14:
 1301              		.align	2
 1302              		.global	CyU3PFreeHeaps
 1304              	CyU3PFreeHeaps:
 1305              	.LFB15:
 530:../cyfxtx.c   **** 
 531:../cyfxtx.c   **** void
 532:../cyfxtx.c   **** CyU3PFreeHeaps (
 533:../cyfxtx.c   **** 	void)
 534:../cyfxtx.c   **** {
 1306              		.loc 1 534 0
 1307              		.cfi_startproc
 1308              		@ args = 0, pretend = 0, frame = 0
 1309              		@ frame_needed = 1, uses_anonymous_args = 0
 1310 0b4c 00482DE9 		stmfd	sp!, {fp, lr}
 1311              	.LCFI30:
 1312              		.cfi_def_cfa_offset 8
 1313              		.cfi_offset 11, -8
 1314              		.cfi_offset 14, -4
 1315 0b50 04B08DE2 		add	fp, sp, #4
 1316              	.LCFI31:
 1317              		.cfi_def_cfa 11, 4
 535:../cyfxtx.c   ****     /* Free up the mem and buffer heaps. */
 536:../cyfxtx.c   ****     CyU3PDmaBufferDeInit ();
 1318              		.loc 1 536 0
 1319 0b54 FEFFFFEB 		bl	CyU3PDmaBufferDeInit
 537:../cyfxtx.c   ****     CyU3PBytePoolDestroy (&glMemBytePool);
 1320              		.loc 1 537 0
 1321 0b58 10009FE5 		ldr	r0, .L90
 1322 0b5c FEFFFFEB 		bl	_txe_byte_pool_delete
 538:../cyfxtx.c   ****     glMemPoolInit = CyFalse;
 1323              		.loc 1 538 0
 1324 0b60 0C309FE5 		ldr	r3, .L90+4
 1325 0b64 0020A0E3 		mov	r2, #0
 1326 0b68 002083E5 		str	r2, [r3]
 539:../cyfxtx.c   **** }
 1327              		.loc 1 539 0
 1328 0b6c 0088BDE8 		ldmfd	sp!, {fp, pc}
 1329              	.L91:
 1330              		.align	2
 1331              	.L90:
 1332 0b70 00000000 		.word	glMemBytePool
 1333 0b74 00000000 		.word	glMemPoolInit
 1334              		.cfi_endproc
 1335              	.LFE15:
 1337              	.Letext0:
 1338              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 1339              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 1340              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 1341              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 1342              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 1343              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
DEFINED SYMBOLS
                            *ABS*:00000000 cyfxtx.c
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:21     .bss:00000000 glMemPoolInit
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:18     .bss:00000000 $d
                            *COM*:00000034 glMemBytePool
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:28     .bss:00000004 glBufferManager
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:31     .text:00000000 $a
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:34     .text:00000000 CyU3PUndefinedHandler
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:58     .text:0000000c CyU3PPrefetchHandler
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:81     .text:00000018 CyU3PAbortHandler
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:104    .text:00000024 tx_application_define
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:132    .text:00000040 CyU3PMemInit
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:172    .text:0000008c $d
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:178    .text:00000098 $a
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:181    .text:00000098 CyU3PMemAlloc
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:240    .text:00000118 $d
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:244    .text:0000011c $a
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:247    .text:0000011c CyU3PMemFree
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:276    .text:0000013c CyU3PMemSet
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:380    .text:0000023c CyU3PMemCopy
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:500    .text:00000374 CyU3PMemCmp
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:572    .text:00000414 CyU3PDmaBufferInit
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:669    .text:00000504 $d
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:674    .text:0000050c $a
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:677    .text:0000050c CyU3PDmaBufferDeInit
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:752    .text:000005b4 $d
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:756    .text:000005b8 $a
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:758    .text:000005b8 CyU3PDmaBufMgrSetStatus
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:907    .text:00000754 $d
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:911    .text:00000758 $a
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:914    .text:00000758 CyU3PDmaBufferAlloc
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:1139   .text:000009b4 $d
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:1143   .text:000009b8 $a
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:1146   .text:000009b8 CyU3PDmaBufferFree
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:1297   .text:00000b48 $d
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:1301   .text:00000b4c $a
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:1304   .text:00000b4c CyU3PFreeHeaps
C:\Users\simon\AppData\Local\Temp\ccC5CDNm.s:1332   .text:00000b70 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PApplicationDefine
_txe_byte_pool_create
_tx_thread_identify
_txe_byte_allocate
_txe_byte_release
_txe_mutex_create
_txe_mutex_delete
_txe_mutex_get
_txe_mutex_put
_txe_byte_pool_delete
