/***********************************************************************************************************************\
 * Program Name		:	cyusbd.c										*
 * Author		:	V. Radhakrishnan ( rk@atr-labs.com )							*
 * License		:	GPL Ver 2.0										*
 * Copyright		:	Cypress Semiconductors Inc. / ATR-LABS							*
 * Date written		:	March 7, 2012										*
 * Modification Notes	:												*
 * 															*
 * This program may be run as a deamon process. It obtains all device details for relevant				*
 * Cypress devices ( as listed in /etc/cyusb.conf ) and waits for two kinds of signals ( SIGUSR1 and SIGUSR2 )		*
 * SIGUSR1 signal is handled when a notification arrives from the kernel whenever a usb device gets added/deleted	*
 * in which case the device list is refreshed. SIGUSR1 would be generated by a script from a persistent udev rule 	*
 *															*
 * SIGUSR2 signal is a request to free all resources and exit. 								*
\***********************************************************************************************************************/

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <getopt.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>

#include <libusb-1.0/libusb.h>

#include "cyusb.h"

/********** Cut and paste the following & modify as required  **********/
static const char * program_name;
static const char *const short_options = "hv";
static const struct option long_options[] = {
		{ "help",	0,	NULL,	'h'	},
		{ "version",	0,	NULL,	'v'	},
		{ NULL,		0,	NULL,	 0	}
};

static int next_option;

static void print_usage(FILE *stream, int exit_code)
{
	fprintf(stream, "Usage: %s options\n", program_name);
	fprintf(stream, 
		"  -h  --help           Display this usage information.\n"
		"  -v  --version        Print version.\n");

	exit(exit_code);
}
/***********************************************************************/

extern char pidfile[256];
extern char logfile[256];
extern int logfd;
extern int pidfd;

struct VPD {
	unsigned short	vid;
	unsigned short	pid;
	char		desc[30];
};

extern struct VPD vpd[100];
extern int maxdevices;
extern int numdev;
extern libusb_device **list;

extern struct cydev cydev[MAXDEVICES];

static void handle_sigusr1(int signo)
{
	int N;

	printf("Signal SIGUSR1 received !\n");
	cyusb_close();
	N = cyusb_open();
	if ( N < 0 ) {
	   printf("Error in opening library\n");
	   exit(-1);
	}
	else if ( N == 0 ) {
		printf("No device of interest found\n");
		 exit(0);
	}
	else printf("No of devices of interest found = %d\n",N);
}

static void handle_sigusr2(int signo)
{
	unlink(pidfile);
	close(logfd);
	cyusb_close();
	exit(0);
}

static void validate_inputs(void)
{

}

int main(int argc, char **argv)
{
	int N;
	int pid;
	char tbuf[50];
	int r;

	N = cyusb_open();
	if ( N < 0 ) {
	   printf("Error in opening library\n");
	   return -1;
	}
	else if ( N == 0 ) {
		printf("No device of interest found\n");
		return 0;
	}
	else printf("No of devices of interest found = %d\n",N);

	logfd = open(logfile, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR );
	if ( logfd < 0 ) {
	   printf("Error opening log file for output %s\n",logfile);
	   cyusb_close();
	   return -2;
	}
	program_name = argv[0];
	while ( (next_option = getopt_long(argc, argv, short_options, 
					   long_options, NULL) ) != -1 ) {
		switch ( next_option ) {
			case 'h': /* -h or --help  */
				  print_usage(stdout, 0);
			case 'v': /* -v or --version */
				  printf("cyusbd (Ver 1.0)\n");
				  printf("Copyright (C) 2012 Cypress Semiconductors / ATR-LABS\n");
				  exit(0);
			case '?': /* Invalid option */
				  print_usage(stdout, 1);
			default : /* Something else, unexpected */
				  cyusb_close();
				  abort();
		}
	} 
	validate_inputs();

	pid = getpid();
	pidfd = open(pidfile, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR );
	if ( pidfd < 0 ) {
	   printf("Error opening pid file for output %s\n",pidfile);
	   cyusb_close();
	   return -3;
	}
	else {
		memset(tbuf,' ',50);
		sprintf(tbuf,"%d\n",pid);
		write(pidfd, tbuf, strlen(tbuf));
		close(pidfd);
	}

	signal(SIGUSR1,handle_sigusr1);  /* Signal to handle events received from the kernel			*/
	signal(SIGUSR2,handle_sigusr2);  /* Signal to stop this daemon and exit gracefully			*/
	signal(SIGINT, handle_sigusr2);  /* Ctrl_C will also stop this daemon and exit gracefully		*/

	while (1) {
		pause();
	}
	return 0;
}
